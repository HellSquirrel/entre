---
title: 'А чего мльного у нас нынче на фронте?'
date: '2022-04-08T17:04:15.630Z'
tags: ['ML/DL']
slug: 'state-of-ml-on-the-frontend'
published: true
---

import Image from 'next/image'
import ImperativeSquirrel from '../pages/experiments/demos/imperativeSquirrel.tsx'

import tf from './assets/tf.png'
import SquirrelCoords from './assets/squirrelCoords.svg'
import Squirrel from './assets/squirrel.svg'

# А чего MLного у нас нынче на фронте?

Поговорим о том как умножая и складывая матрицы получать крутые спецэффекты... А иногда и делать что-то полезное.
Начну с вымышленной истории :)

## Маленький фронтенд который боялся математики

Жил-был фронтенд-разработчик. Он не сразу стал заниматься фронтом. Сначала он закончил крутые курсы, научился в React и Redux.
Он устроился в крупную компанию, верстал там формочки и был счастлив.
Но однажды к нему пришел грустный техлид проекта.
Он рассказал как в их чудесном сервисе где можно подгружать видяшки с белочками стали появляться видяшки с котиками и что это совершенно недопустимо.
Нужен какой-то способ понять что на видео не белочка, а котик и предупредить пользователя об этой ужасной ошибке!

Фронтенд пошел гуглить. К сожалению, по запросу "js отличить белочку от котика" ничего толкового не нашлось.
Но вот на stackoverflow ему посоветовали использовать очень крутой фреймворк для распознавания белочек. Tensorflow называется
Фронтенд пошел читать документацию ...
Сначала ему почему-то рекомандовали установить питон (а как известно некоторые фронтенды боятся змей),
Потом фронтенд заглянул в следующий раздел и увидел вот такое:

<Image {...tf} />

Тензоры? Дата сеты? Слайсы? Фронтенд загрустил и решил делегировать задачу департаменту машинного обучения. Правда потом он вспомнил что такого департамента в их компании нет :)

## A собственно чего тут бояться?

Почему подобные задачи кажутся сложными? Потому что иногда мы боимся математики. Этот страх появляется еще в школе и развивается превращаясь в уверенность "вот никогда-никогда никаких логарифмов и интегралов".
Боимся мы зря. Математика значительно упрощают фронтожизнь.

Большинтсво читателей наверняка когда - нибудь пользовались CSS
Наверное приходилось писать вот такое:

```css
.squirrel {
  transform: translateX(100px);
}
```

А некоторым и вот такое:

```css
.squirrel {
  transform: skewX(1);
}
```

А иногда и вот такое

```css
.squirrel {
  transform: rotate(90deg);
}
```

Для всех случаев можно написать одну общую трансформацию :

```css
.squirrel {
  transform: matrix3d(0, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, -100, 0, 0, 1);
}
```

Прикольно же: не надо думать, надо просто подставить нужные циферки в нужное место

Пожалуй надо уточнить что matrix это двумерный массив.

```js
;[
  [0, -1, 0, 0],
  [1, 0, 0, 0],
  [0, 0, 1, 0],
  [-100, 0, 0, 1],
]
```

И раз уж мы заговорили о массивах... Массивы могут быть многомерными.
В контексте ML мы называем многомерные массивы с элементами одного типа тензорами.
Это не вполне корректно, но все что нам нужно знать это:

1. Тензор можно представить как многомерный массив
2. У тензора есть ранг и размерность.
   Ранг это сколько индексов нам понадобится чтобы достать элемент из тензора.
   Размерность это количество элементов по каждой из осей.
   Наша матрица из примера это тензор ранга 2 размерностью `3 x 3`.
3. Как правило тензоры описывают преобразования между элементами нашего пространства.

Посмотрим как это работает на нашей белочке: Для каждого беличьего пискеля с координатами `x y` мы можем получить новые координаты умножив `x y` на матрицу из снипета выше.

<SquirrelCoords className="img" />

Окей. С тензорами разобрались и математики больше не боимся. Поехали дальше.

## Декларативно или императивно?

Есть два стиля написания кода: декларативный и императивный

В первом случае у нас есть некая машинерия которая позволяет нам формулировать проблемы на человеческом языке
и описывать решения этих проблем в виде "я хочу чтобы..."

При этом, используя декларативный подход мы не особо заморачиваемся на детали реализации. Мы говорим _что_ мы хотим. Нам не важно _как_ мы получим результат.
А вот используя императивный мы сосредотачиваемся на деталях реализации.

Давайте сделаем что-нибудь императивное :)
Есть картинка белочки. Нужно ее заблюрить.
Я не буду приводить здесь код преобразования пикселей в `Uint8ClampedArray` и рисования красивостей на `canvas`
Посмотрим только на блюрющую математику

```js
const kernel = [
  [1 / 16, 1 / 8, 1 / 16],
  [1 / 8, 1 / 4, 1 / 8],
  [1 / 16, 1 / 8, 1 / 16],
]

const convStep = (arr1: number[], kernel): number =>
  kernel.flat().reduce((acc, v, i) => acc + v * arr1[i], 0)

const convolve = (
  array: Uint8ClampedArray,
  kernel: number[][],
  w: number,
  h: number,
  stride = 1,
  chInImage = 4
): Uint8ClampedArray => {
  const result = new Uint8ClampedArray(w * h * chInImage).fill(255)
  const kh = kernel.length
  const kw = kernel[0].length

  for (let i = 0; i < w - kw; i += stride) {
    for (let j = 0; j < h - kh; j += stride) {
      for (let c = 0; c < chInImage; c++) {
        const arrToConsolve: number[] = []
        for (let k = 0; k < kw; k++) {
          for (let l = 0; l < kh; l++) {
            arrToConsolve.push(
              array[
                chInImage * w * j +
                  chInImage * i +
                  c +
                  chInImage * k +
                  chInImage * l * kw
              ]
            )
          }
        }

        const convStepResult = convStep(arrToConsolve, kernel)
        result[chInImage * w * j + chInImage * i + c] = convStepResult
      }
    }
  }

  return result
}

const blurredSquirrel = convolve(
  imagePixels,
  kernel,
  originalSquirrel.width,
  originalSquirrel.height
)
```

Мало того что мы заблюрили белочку мы еще и побили рекорд. 5! вложенных циклов `for`

<ImperativeSquirrel />

Вот это и есть императивный подход. У нас есть готовые числа (их еще называют ядром (и мы теперь знаем что это тензор :)). Мы берем эти числа и выполняем заранее известные преобразования.
Для блюра белочки мы использовали операцию [convolve](https://en.wikipedia.org/wiki/Convolution). Эта операция берет матрицу заданного размера, выбирает кусочек картинки такого же размаре и "сворачивает" их вместе.
Сворачиваем так: перемножаем все значения матрицы на значения соответствующих пикселей. А потом складываем все результаты.

Выбирая правильные ядра мы можем по-разному преобразовывать нашу картинку:

- детектировать грани разных направлений
- сглаживать и шарпить
- менять цвета, яркость и контраст

## Декларативность первый шаг

Давайте еще раз посмотрим на нашу белочку.

<Squirrel className="img" />

Вне зависимости от того какую задачу мы решаем, нам понадобится преставить белочку в виде циферок :)
Первый делом мы просто превратим наше изображение в набор сырых пикселей.

Если размрер белочки `M * N (2388 x 1668)` и белочка черно-белая (мы используем только один канал), то нам понадобится матрица размером `2388 x 1668 x 1`.

Работать с такими большими объемами данных тяжело. Для примера с блюром, время заблюривания линейно зависит от `M x N`
Хорошие новости – нам не нужны все пиксели нашего изображения.
Вместо этого мы можем представить нашу белочку как-то иначе.

## Фичи

Если мы "расплющим" беличью матрицу, получится боооольшой массив длинной 3983184 (это примерно 3.8 Mb).
С другой стороны, если мы сохраним белочку в фромате SVG, мы получим всего 16Kb.
При этом мы можем смотреть на наше изображение как на набор геометрических примитивов. Простых: кружочки и квадратики которые в свою очередь формируют более сложные – беличий хвост.
Дальше мы можем как-нибудь закодировать наши геометрические примитивы и получить тензор с "фичами" которые можно использовать для решения нужной нам задачи.
Часть информации о белочке при этом потеряется, но при должной сноровке мы сможем восстановить белочку из этих фич.

Давайте попробуем это сделать, использовав [PCA](https://en.wikipedia.org/wiki/Principal_component_analysis)

Решаем следующую задачу: сколько фич нам нужно чтобы уверенно отличать белочку от других картинок нарисованных моими кривыми лапками?

## ML за 2 минуты:

На нейросеточку можно смотреть как на функцию. На входу у нас какая-то инфа об окружающем мире на выходе некая информация. Это может быть предсказание или обобщение

Пример: "у Полины еще один доклад на хайпотему" => (магия нейросети) => токсичность: уровень Бог!

Когда мы пишем функции в JS в теле функции мы описываем как функция будет вычислять результат (да, да даже если мы действуем ооочень декларативно!)
Когда мы используем нейросетку мы тоже описываем как она будет вычислять результат
Сравните:

JS:

```
const createValueGetter = (a, b) => (x) => a*x + b
const getValue = createValueGetter(2, 5)
console.log([1,2].map(getValue)) // [7, 9]
```

ML: все то же самое, но у нас уже есть значения

```
const values = [1, 2]
const realResults = [7, 9]
// const getValueWithML =  ??

let a = Math.random()
let b = Math.random()
let step = 0.01
const doTrain = (aPrev, bPrev, prevDelta) => {
    const aNext = aPrev + delta
    const bNext = aNext + delta
    const getValueCandidate = createValueGetter(aPrev, bPrev)
    const results = values.map(getValueCandidate)
    const delta = results.reduce((acc, res, index) => acc + Math.abs(res - realResults[i]), 0)
}

// TODO continue an example


```

## TODO а что это вообще такое?

Мой коллега утверждает что tf это как функциональное программирование :)

## TODO Tensorflow tools

[tf-vis](https://js.tensorflow.org/api_vis/latest/)

## Tensorflow производительность

Иногда рекомендуют использовать spritesheets для тренировки CNN. Но вспомните в каком мы году!
Все уже давно используют http/2 а некоторые даже http/3. Новые версии протоколов поддерживают мультиплексирование.
Так что никакие спрайты вам не нужны

А вот то о чем не стоит забывать это пожираемая память. Есть специальная функция tf.tidy, которая позволяет вычищать промежуточные тензоры из памяти

Tensorflow очень тяжелый пакет

## TODO как появился tensorflow

## TODO где гонять модели? (Cloud functions, browser)

Итак у нас есть два сценария применения чудо-ml

1. У нас нет обученной модели. Тогда нам нужно ее обучить.
2. У нас уже загруженная моделька. Ее нужно погонять
3. У нас уже загруженная моделька, но нам ее надо доучить (transfer learning). Зачем это может быть нужно?
   Сценарий: у нас офигительно интерактивный процесс обучения. Мы не успеем все научить на сервере (например мы учим модельку с видео нашей камеры)

## Onnx js

## Всякие разные бекенды

Я покажу
