---
title: 'Магия декларативности и cхемы. Часть 1: Парсим GraphQL запросы'
date: '2022-08-07T05:55:58.570Z'
tags: ['GraphQL', 'Compilers']
slug: declarative-schema-parsing-1
published: true
description: 'Разбираем graphql на винтики'
---

import { Details } from '../components/Details'
import { CodeSnippet } from '../components/CodeSnippet'
import schema from '../components/graphql/schema.graphql'
import validQuery from '../components/graphql/validQuery.graphql'
import incorrectQuery from '../components/graphql/incorrectQuery.graphql'
import parseRaw from '!raw-loader!../components/graphql/parse.ts'
import parseIncorrectRaw from '!raw-loader!../components/graphql/parseIncorrect.ts'
import { parseIncorrect } from '../components/graphql/parseIncorrect.ts'

import { gql } from '@apollo/client'

Когда начинается новый проект или пилится новый микросервис, стоит остановиться и подумать о том как мы организовываем взаимодействие напиливаемого с остальным миром.
Давайте порассуждаем как должен выглядеть хороший бекенд и как определить что он правильно подходит под нашу задачу.

## Декларативно и императивно

Пусть у нас есть система. Мы можем взаимодействовать с ней двумя способами.
Императивно – выдать системе инструкции которые она будет выполнять. Мы будем _ожидать_ что в результате мы получим что хотим
Декларативно – сообщить системе что мы хотим. Она сама определит порядок действий чтобы выдать нам желаемое.
В первом случае контроль на нашей стороне, во втором - на стороне системы. Как лучше зависит от задачи. Но часто оказывается что передавать
контроль системе хорошая идея. Ведь система лучше знает как она устроена и ее разработчики наверняка постарались оптимизировать выполнение наших запросов.

Дальше нам каким-то образом нужно описать что мы хотим на языке понятном системе. Для этого нам нужен *Q*uery *L*anguage.

Давайте посмотрим как это выглядит для GraphQL. Мы будем делать wiki для любителей функционального программирования.
Каждая страничка wiki будет описывать какой-нибудь алгебраический тип.

<Details title="Если вы ничего не знаете о graphql не беда">
  Вот
  [тут](https://speakerdeck.com/hellsquirrel/graphql-ponimaiem-obiasniaiem-vniedriaiem)
  можно посмотреть слайды моего доклада в котором я все объясняю. А вот
  [тут](https://www.youtube.com/watch?v=wko-uoILG_w) сам доклад.
</Details>

## SRP – Нас интересует только запрос и ответ. Нам все равно что и куда мы отправляем.

Одно из преимуществ GraphQL его не зависимость от транспорта. Все что нам нужно это отправить запрос и получить ответ.
Нам все равно каким способом этот ответ будет доставлен.

## Как сделать правильный запрос?

Используя QueryLanguage нам нужно сделать только те запросы, которые будут понятны нашей системе.
Давайте подумаем по каким причинам запросы могут быть непонятными:

- У нас ошибка в грамматике
- С грамматикой все окей, но мы просим то, что система не может нам дать

Теперь откроем нашу любимую IDE и напишем какой – нибудь graphql запрос.

`touch validQuery.graphql`

<CodeSnippet code={validQuery} lang="graphql" />

Дальше GraphQL execution engine должен выполнить этот запрос. Но есть проблема :)

Наш запрос это текст. Как известно машины текст не понимают :) Поэтому, как и для любого другого языка нам нужно получить
_промежуточное представление_ нашего языка в виде конструкции понятной execution engine.

Это легко. Воспользуемся `graphql-tag`.

Ставим зависимости

`yarn add @apollo/client graphql`

И натравливаем `graphql-tag` на наш запрос

<Details title="Apollo?">
  Я буду использовать `graphql-tag` из библиотеки
  [Apollo](https://www.apollographql.com/docs/react/), потому что нам еще многое
  оттуда понадобится. Но вы можете установить `graphql-tag` отдельно
</Details>

<CodeSnippet code={parseRaw} lang="ts" />

<Details title="Oй какие симпатичные бэктики!">
  Ага. Если еще не интересовались, почитайте про [tagged template
  literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates).
</Details>

В объекте query будет лежать результат парсинга. И сейчас немножко капитанства про парсеры:
Когда вам нужно попарсить какой-то текст, у вас есть множество способов это сделать. Одни из них такой:
Берете грамматику вашего языка. Для GraphQL она описана в [спецификации](https://spec.graphql.org/draft/#sec-Language). И начинаете на основе этой грамматики строить
дерево запроса. Главное что нужно понимать:

- вам нужна грамматика
- если ваш запрос грамматически не верный парсер упадет

`graphql-tag` вызывает метод `parseDocument` из `graphql-js` чтобы проделать этот трюк.
Если вам интересно как устроен `graphql-js` парсер, можете заглянуть [вот сюда](https://github.com/graphql/graphql-js/blob/main/src/language/parser.ts)

Вот что мы получим в результате

<CodeSnippet code={JSON.stringify(gql(validQuery), null, ' ')} lang="json" />

A теперь давайте сломаем наш запрос

<CodeSnippet code={incorrectQuery} lang="graphql" />

Поймаем ошибку и подробненько ее изучим.

<CodeSnippet code={parseIncorrectRaw} lang="ts" />

<CodeSnippet code={parseIncorrect()} lang="json" />

Наш код упал во время парсинга. То же самое сделает graphql engine если попросить его выполнить грамматически некорректный graphql запрос.

<Details title="Как импортитровать этот странный graphql?">
    Обратите внимание: я особо не заморачиваясь импортирую `.graphql` файлики в
    свой код. Из коробки это работать не будет. В случае моего блога, я читерю
    используя `raw-loader` из webpack. В production вы наверняка захотите делать
    иначе. Советую глянуть [вот
    сюда](https://www.apollographql.com/docs/react/integrations/webpack/) чтобы
    понять как прикрутить `graphql-tag` для правильного импорта ваших graphql
    запросов.

    Вторая проблема возникнет у вас если вы используете TypeScript. TS ничего не знает о странных модулях с расширением .graphql.
    Чтобы это починить создайте где-нибудь в корне вашего проекта файл custom-types.d.ts (если у вас такого еще нет) и добавьте туда


    ```ts
    declare module '*.graphql' {
      const contents: string
      export = contents
    }
    ```
    Это сработает для `raw-loader`. Для `graphql-tag/loader` вам понадобится заменить string на другой тип.

</Details>

## С парсингом разобрались. Что Дальше?

Теперь мы понимаем как GraphQL query language, как натравить на свой запрос парсер и какие дальше возможны сценарии.
Это только первый шаг в нашем пайплайне. В следующем посте посмотрим на то как мы можем выполнять или _не_ выполнять GraphQL запросы.
