---
title: 'Магия декларативности и cхемы. Часть 5: Тесты'
date: '2022-08-07T10:55:58.570Z'
tags: ['GraphQL', 'Compilers']
slug: declarative-schema-parsing-5
published: true
description: 'Разбираем graphql на винтики'
---

import { Details } from '../components/Details'
import { CodeSnippet } from '../components/CodeSnippet'
import schema from '../components/graphql/schema.graphql'
import { gql } from '@apollo/client'
import validQuery from '../components/graphql/validQuery.graphql'
import MaybePageTestCodeV1 from '!raw-loader!../components/graphql/MaybePageV1.test.tsx'
import MaybePageTestCodeV2 from '!raw-loader!../components/graphql/MaybePageV2.test.tsx'

<Details title="Напоминалка про пример">
  Вы уже добралить до четвертого поста и наверняка помните, что мы пишем wiki
  для любителей функционального программирования. Каждая страничка посвящена алгебраическому типу.

У нас уже есть готовый запрос

<CodeSnippet code={validQuery} lang="graphql" />

И схема

  <CodeSnippet code={schema} lang="graphql" />
</Details>

## Все уже достаточно надежно?

У нас уже есть линтеры и проверка типов по схеме. Можем ли мы каким-то дополнительным образом гарантировать надежность нашего приложения?
Разумеется. Настало время написать тесты.

### Чуть-чуть холивара про Apollo, архитектуру и тесты

Думать об архитектуре – штука полезная. Многие фреймворки, такие как `apollo` предоставляют вам возможность
использовать GraphQL запросы прямо внутри ваших компонентов. Кроме этого `apollo` заботится обо всех нюансах взаимодействия с вашим GraphQL engine (где бы он ни находился): делает запросы, денормализует ответы и заботливо складывает все в стор.

Очень частый пример использования apollo такой: вы просто закидываете хуки в самое удобное место в вашем компоненте и работаете с данными которые выдал вам GraphQL движок прямо на месте.
У такого подхода есть очевидный плюс – думать не надо :) Более того, если у вас не очень сложная стуктура файлов, никаких хитрых процессов работы с данными, полученными от GraphQL engine не планируется, то изобретать велосипед не имеет смысла.
Вот только если вы будете недостаточно аккуратны, логика вашего представления смешается с логикой работы с graphql движком и с поддержкой вашего кода все постепенно станет плохо.

Например:
К вам приходит грустный бекенд и сообщает что его сервер мучают большим количеством однотипных GraphQL запросов.
Вы пойдете разбираться и найдете десяток компонентов которые используют различные вариации этого запроса. Да еще пробрасывают ответ дальше по дереву.
Оптимизировать что-то в подобной ситуации будет не просто.

Решение тут достаточно простое: вытащите логику взаимодействия с вашим GraphQL запросом на отдельный слой.
Для этого вам совсем не обязательно заводить папки со странными названиями в строгом соответствии рекомендациями дядюшки Боба.
Просто следите за структурой ваших компонетов и старайтесь чтобы логику взаимодействия с вашим запросом было легко обнаружить и починить.

Вы можете пойти дальше и запретить выполнять GraphQL запросы из ваших компонентов. Сложить все связанное с GraphQL в отдельное место и придумать свой собственный ~велосипед~ интерфейс взаимодействия с этим всем.

Что бы вы ни выбрали, если вы хотите получить действительно надежную систему вам придется написать для нее тесты.
Если ваш фреймворк берет на себя все взаимодействие с GraphQL то для этого взаимодействия тесты вам разумеется писать не нужно.

В примере с Apollo вот такой тест будет лишним

```tsx
const testQuery = gql`
  query TestPages {
    allPages {
      id
      text
    }
  }
`

test('it works!', async () => {
  const response = await client.query({ query: testQuery })
  expect(response.data.allPages).toBeDefined()
})
```

Однако если вы:

1. Тестируете логику процессинга ваших GraphQL данных
2. Тестируете работу компонента, который использует GraphQL
3. Тестируете хитрый хук который как-то использует GraphQL

напишите для этого тесты :)

## Как написать тесты, если в лапках держим схему?

Вам понадобится сущность, которая инкапсулирует логику работы в вашим GraphQL движком. Если у вас такой нет, подумайте все ли окей с архитектурой вашего приложения :)

До тех пор пока вы не начали писать интеграционные тесты забудьте что у вас есть настоящий GraphQL сервер.
Замокайте эту сущность или попросите ваш фреймворк сделать это за вас. Мы уже научились мокать наш GraphQL engine, помните?

Используйте замоканное в тестах.

## apollo client case

В случае если вы используете apollo client и react все уже сделано за вас. Нужно просто воспользоваться [MockedProvider](https://www.apollographql.com/docs/react/development-testing/testing/)
Я примерах тестов я буду использовать [@testing-library](https://testing-library.com/)

<CodeSnippet code={MaybePageTestCodeV1} lang="tsx" />

В качестве мока мы просто закидываем запрос и ожидаемый ответ. Дальше первым expect проверяем состояние загрузки, вторым – что загруженные данные успешно отрендерились

Но если данные нас не особо волнуют или мы хотим только частично поменять ответ, то мы можем воспользоваться автомоками. Я рассказывала о них во [второй части](/graphql/declarative-schema-parsing-5) этой серии постов.

<CodeSnippet code={MaybePageTestCodeV2} lang="tsx" />

Чтобы не повторяться мы написали два хелпера `getSchemaWithMocks` и `createMock`. Мы можем продолжить наш рефакторинг дальше, например добавив наши моки примо в объект MockedProvider,
но я здесь всего лишь хотела показать идею :)

<Details title="А как настроить Jest и testing library?">
  Ответ на этот вопрос лежит за скоупом этой статьи. В документации все
  подробненько расписано. Единственная трудность на которую я хочу обратить ваше
  внимание это то как заставить Jest понимать .graphql файлики. Вам понадобится
  специальный [трансформер](https://jestjs.io/docs/code-transformation). Тут
  возможны два сценария: 
  1. Если вы грузите grapqhl raw-loaderом, как я в этих
  постах, можете написать свой.

```js
// raw-transformer.js
module.exports = {
  process(sourceText) {
    return {
      code: `module.exports = ${JSON.stringify(sourceText)}`,
    }
  },
}
```

и добавить его в конфиг Jest:

```js
// jest.config.js
module.exports = {
  // ...
  transform: {
    '.(graphql|gql)$': '<rootDir>/raw-transformer.js',
  },
}
```

2. Вы используете `grapqhl-tag/loader`
   Тогда просто воспользуйтесь готовым транcформером [`jest-transform-graphql`](https://www.npmjs.com/package/jest-transform-graphql)

</Details>

## Осталось чуть-чуть

Теперь мы понимаем как сделать наше приложение еще более надежным, добавив тесты. В следующем (и я надеюсь завершающем 😅) посте я расскажу как защищаться от злобных бекендов удаляющих ваши любимые поля
