---
title: 'Магия декларативности в cхемы. Часть 1: Парсим GraphQL запросы'
date: '2022-07-16T05:55:58.570Z'
tags: ['GraphQL', 'Compilers']
slug: declarative-schema-parsing-1
published: false
description: 'Разбираем graphql на винтики'
---

import { Details } from '../components/Details'
import { CodeSnippet } from '../components/CodeSnippet'
import schema from '../components/graphql/schema.graphql'
import validQuery from '../components/graphql/validQuery.graphql'
import invalidQuery from '../components/graphql/invalidQuery.graphql'
import parseRaw from '!raw-loader!../components/graphql/parse.ts'
import { gql } from '@apollo/client'

# Фронты рассуждают об идеальном бекенде. Их ли это дело.

Когда начинается новый проект или пилится новый микросервис, стоит остановиться и подумать о том как мы организовываем взаимодействие напиливаемого с остальным миром.
Давайте порассуждаем как должен выглядеть хороший бекенд и как определить что он правильно подходит под нашу задачу.

## Декларативно и императивно

Пусть у нас есть система. Мы можем взаимодействовать с ней двумя способами.
Императивно – выдать системе инструкции которые она будет выполнять. Мы будем _ожидать_ что в результате мы получим что хотим
Декларативно – сообщить системе что мы хотим. Она сама определит порядок действий чтобы выдать нам желаемое.
В первом случае контроль на нашей стороне, во втором - на стороне системы. Как лучше зависит от задачи. Но часто оказывается что передавать
контроль системе хорошая идея. Ведь система лучше знает как она устроена и ее разработчики наверняка постарались оптимизировать выполнение наших запросов.

Дальше нам каким-то образом нужно описать что мы хотим на языке понятном системе. Для этого нам нужен *Q*uery *L*anguage.

Давайте посмотрим как это выглядит для GraphQL. Мы будем делать wiki для любителей функционального программирования.
Каждая страничка wiki будет описывать какой-нибудь алгебраический тип.

<Details title="Если вы ничего не знаете о graphql не беда">
  Вот
  [тут](https://speakerdeck.com/hellsquirrel/graphql-ponimaiem-obiasniaiem-vniedriaiem)
  можно посмотреть слайды моего доклада в котором я все объясняю. А вот
  [тут](https://www.youtube.com/watch?v=wko-uoILG_w) сам доклад.
</Details>

## SRP – Нас интересует только запрос и ответ. Нам все равно что и куда мы отправляем.

Одно из преимуществ GraphQL его не зависимость от транспорта. Все что нам нужно это отправить запрос и получить ответ.
Нам все равно каким способом этот ответ будет доставлен.

## Как сделать правильный запрос?

Используя QueryLanguage нам нужно сделать только те запросы, которые будут понятны нашей системе.
Давайте подумаем по каким причинам запросы могут быть непонятными:

- У нас ошибка в грамматике
- С грамматикой все окей, но мы просим то, что система не может нам дать

Теперь откроем нашу любимую IDE и напишем какой – нибудь graphql запрос.

`touch validQuery.graphql`

<CodeSnippet code={validQuery} lang="graphql" />

Дальше GraphQL execution engine должен выполнить этот запрос. Но есть проблема :)

Наш запрос это текст. Как известно машины текст не понимают :) Поэтому, как и для любого другого языка нам нужно получить
_промежуточное представление_ нашего языка в виде конструкции понятной execution engine.

Это легко. Воспользуемся `graphql-tag`.

Ставим зависимости

`yarn add @apollo/client graphql`

И натравливаем `graphql-tag` на наш запрос

<Details title="Apollo?">
  Я буду использовать `graphql-tag` из библиотеки
  [Apollo](https://www.apollographql.com/docs/react/), потому что нам еще многое
  оттуда понадобится. Но вы можете установить `graphql-tag` отдельно
</Details>

<CodeSnippet code={parseRaw} lang="ts" />

<Details title="Oй какие симпатичные бэктики!">
  Ага. Если еще не интересовались, почитайте про [tagged template
  literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates).
</Details>

В объекте query будет лежать результат парсинга. И сейчас немножко капитанства про парсеры:
Когда вам нужно попарсить какой-то текст, у вас есть множество способов это сделать. Одни из них такой:
Берете грамматику вашего языка. Для GraphQL она описана в [спецификации](https://spec.graphql.org/draft/#sec-Language). И начинаете на основе этой грамматики строить
дерево запроса. Главное что нужно понимать:

- вам нужна грамматика
- если ваш запрос грамматически не верный парсер упадет

`graphql-tag` вызывает метод `parseDocument` из `graphql-js` чтобы проделать этот трюк.
Если вам интересно как устроен `graphql-js` парсер, можете заглянуть [вот сюда](https://github.com/graphql/graphql-js/blob/main/src/language/parser.ts)

Вот что мы получим в результате

<CodeSnippet code={JSON.stringify(gql(validQuery), null, ' ')} lang="json" />

A теперь давайте сломаем наш запрос

<CodeSnippet code={invalidQuery} lang="graphql" />

, то нам понадобится еще и схема - структура, которая описывает все что можно попросить
у нашей системы.

## Tool #1 – IDE для создания схемы

Берем VSCode или любой ваш любимый редактор.
Создаем файлик схемы `touch schema.graphql`.

<CodeSnippet code={schema} lang="graphql" />

И давайте создадим валидный запрос, который будет соответствовать нашей схеме

## Tool #2 - graphql js.

Как только у нас появилась схема мы можем воспользоваться третьим ингридиентом Graphql

<Details title="Кстати, а что из вышеперечисленного GraphQL">
  По спеке: GraphQL query language _and_ execution engine. Т.е все что было
  описываем GraphQL
</Details>

## ToolSet #2 – Автоматическая документация

Как только у нас появилась схема мы можем красиво скомпоновать нашу информацию о типах и нести ее в коллегам. Наша документация будет обновняться вместе со схемой.
И нам не понадобится время и силы на ее поддержку.
Инструментов для генерации подобной документации огромное количество.
Например есть супермощный [ApolloStudioExplorer](https://www.apollographql.com/docs/studio/explorer/explorer/).

<Details title="Apollo studio платформа которая предоставляет множество фич для работы с графом">
  Мы еще несколько раз будем упоминать этот замечательный инструмент по ходу
  повествования.
</Details>

Но мы возьмем что-то более простое

## Tool #3 – Graphql Voyager

Что мы сейчас описали в этой схеме? Бизнес - домен.

Можно ли как-нибудь красиво отобразить то что у нас получилось?
Разумеется можно. Наша схема это граф. Этот граф может быть циклическим. В нашем случае цикл возникает из-за поля isAliasFor.

<Details title="вам совсем не обязательно описывать бизнес-домен">
  Есть множество примеров использования GraphQL, включая достаточно
  экзотические, типа [Gatsby](https://www.gatsbyjs.com/).
</Details>

Вот там мы просим пользователя и продукт

```graphql
query {
  viewer {
    id
    name
  }

  product(id: 5) {
    title
    quantity
    tags
  }
}
```

А вот так выглядит наша схема. Из нее следует что запрос вполне валидный

```graphql
type Query {
  viewer: User
  product(id: ID!): Product
}
```

## Декларативность + схема = 🚪 в мир новых возможностей

Теперь давайте создадим

Если мы запрашиваем какие-нибудь данные, то нам понадобится еще и схема - структура, которая описывает все что можно попросить у нашей системы.
