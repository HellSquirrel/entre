---
title: 'WebAssembly на клиенте'
date: '2022-11-14T17:03:18.461Z'
tags: ['Wasm']
slug: 'wasm-on-the-client'
published: false
description: Статья о wasm в браузере и не только
---

import { Image } from '../components/Image'
import { Details } from '../components/Details'

import SourceAndTarget from './assets/wasm/sourceAndTarget.png'

## WebAssembly для всех-всех-всех

В этой статье мы поговорим о WabAssembly – моей любимой технологии, которая позволяет принести на клиент почти все, что в голову взбредет.
Пару лет назад я [написала](https://evilmartians.com/chronicles/hands-on-webassembly-try-the-basics) небольшой тьюториал по Wasm.
Технология за это время осталась такой же прекрасной, в ней появилось много новых штук. Так что сейчас будет еще одна статья про Wasm :)

## Как происходит вжух?

Давайте повторим капитанские основы:

Вы пишете программку на вашем любимом языке (может даже на JS!). А потому вжух и она заработала.
Как происходит вжух? Нечто превращает текст написаный человечком (source) в что-то понятное вашему компьютеру (target).
Это нечто называют интерпертаром или компилятором. В современном мире достаточно сложно отличить одно от другого.
Если хотите разобраться что есть что и как работает, почитайте классную [книжку](https://craftinginterpreters.com/)
Давайте считать что интерпретатор – _как-то_ выполняет написанный код, а компилятор превращает что угодно в набор инструкций которые может выполнять ваша машина.

<Image {...sourceAndTarget} />

## Вжух на самом дела вжух-вжух-вжух

Что нужно сделать с вашим исходным кодом, чтобы он превратился в машинный?
Сначала его надо распарсить (убрать наши скучные комменты, понять где функция, где переменная и всякое такое)
Потом, желательно хорошенько перетрясти. Например, вот такой код `const a = 5 + 3` хочется превратить в `положите вон в тот регистр число 8`.
И потом полученное превратить в машинный код.

И так как для разных компиляторов эти этапы похожи было бы здорово иметь возможность для каждого этапа написать свою систему, договориться о входных и выходных форматах и просто собирать новые компиляторы из таких модулей.
Получается компиляция это просто превращение вашего кода из одного промежуточного представения (Intermidiate representation или IR) в другое.

<Details title="Это ментальная модель, на самом деле все сложнее">
  Цепочка промежуточных представлений может быть и не цепочкой вовсе. Например
  V8 (движок для Wasm и JS в Chromium) постоянно превращает кусочки вашего кода
  в разные представления, поддерживая одновременно несколько IR. И параллельно
  собирает фидбек, пытаясь предсказать что произойдет дальше и на основе этих
  предсказаний выбрать правильные оптимизации.
</Details>

Для каждого шага компиляции выбирается такое промежуточное представление с которым будет удобно работать на нужном шаге.
Например V8 – движок для работы с JS и Wasm в браузере Chromium превращает ваш код в байт-код, который выглядит примерно так:

```
CreateFunctionContext [0], [1]
PushContext r2
CreateClosure [1], [0], #2
Star1
LdaZero
Star0
StaCurrentContextSlot [2]
CallUndefinedReceiver0 r1, [0]
LdaCurrentContextSlot [2]
Return
```

К чему это я? WebAssembly это просто промежуточное представление. Достаточно компактное чтобы его было легко распарсить, достаточно низкоуровневое чтобы его можно было оптимизировать.
