---
title: 'WebAssembly на клиенте'
date: '2022-11-14T17:03:18.461Z'
tags: ['Wasm']
slug: 'wasm-on-the-client'
published: false
description: Статья о wasm в браузере и не только
---

import { Image } from '../components/Image'
import { Details } from '../components/Details'

import sourceAndTarget from './assets/wasm/sourceAndTarget.png'
import archtecture from './assets/wasm/archtecture.png'

## WebAssembly для всех-всех-всех

В этой статье мы поговорим о WabAssembly – моей любимой технологии, которая позволяет принести на клиент почти все, что в голову взбредет.
Пару лет назад я [написала](https://evilmartians.com/chronicles/hands-on-webassembly-try-the-basics) небольшой тьюториал по Wasm.
Технология за это время осталась такой же прекрасной, в ней появилось много новых штук. Так что сейчас будет еще одна статья про Wasm :)

## Как происходит вжух?

Давайте повторим капитанские основы:

Вы пишете программку на вашем любимом языке (может даже на JS!). А потому вжух и она заработала.
Как происходит вжух? Нечто превращает текст написаный человечком (source) в что-то понятное вашему компьютеру (target).
Это нечто называют интерпертатором или компилятором. В современном мире достаточно сложно отличить одно от другого.
Если хотите разобраться что есть что и как работает, почитайте классную [книжку](https://craftinginterpreters.com/)
Давайте считать что интерпретатор – _как-то_ выполняет написанный код, а компилятор превращает что угодно в набор инструкций которые может выполнять ваша машина.

<Image {...sourceAndTarget} />

## Вжух на самом дела вжух-вжух-вжух

Что нужно сделать с вашим исходным кодом, чтобы он превратился в машинный?
Сначала его надо распарсить (убрать наши скучные комменты, понять где функция, где переменная и всякое такое)
Потом, желательно хорошенько перетрясти. Например, вот такой код `const a = 5 + 3` хочется превратить в `положите вон в тот регистр число 8`.
И потом полученное превратить в машинный код.

И так как для разных компиляторов эти этапы похожи, было бы здорово иметь возможность для каждого этапа написать свою систему, договориться о входных и выходных форматах и просто собирать новые компиляторы из таких модулей.
Получается компиляция это просто превращение вашего кода из одного промежуточного представления (Intermidiate representation или IR) в другое.

Для каждого шага компиляции выбирается такое промежуточное представление с которым будет удобно работать на нужном шаге.
Например V8 – движок для работы с JS и Wasm в браузере Chromium превращает ваш код в байт-код, который выглядит примерно так:

```
CreateFunctionContext [0], [1]
PushContext r2
CreateClosure [1], [0], #2
Star1
LdaZero
Star0
StaCurrentContextSlot [2]
CallUndefinedReceiver0 r1, [0]
LdaCurrentContextSlot [2]
Return
```

<Details title="Это ментальная модель, на самом деле все сложнее">
  Цепочка промежуточных представлений может быть и не цепочкой вовсе. Например
  V8 постоянно превращает кусочки вашего кода в разные представления,
  поддерживая одновременно несколько IR. И параллельно собирает фидбек, пытаясь
  предсказать что произойдет дальше и на основе этих предсказаний выбрать
  правильные оптимизации.
</Details>

К чему это я? WebAssembly это просто промежуточное представление. Достаточно компактное чтобы его было легко распарсить, достаточно низкоуровневое чтобы его можно было оптимизировать.

## Когда Wasm хорошо и быстро

Почему Wasm легко парсить?
Во-первых потому что это бинарный формат. По крайней мере в таком виде Wasm-модуль приезжает в браузер.
У WebAssembly есть и текстовое представление. Вы легко сможете сконвертировать бинарник в текст и обратно.

<Details title="Вот так выглядит текстовый формат WebAssembly">

```
(module
  (func $i (import "imports" "logger") (param i32))
  (memory (import "imports" "importedMemory") 1)
  (func (export "exportedFunc")
    i32.const 42
    call $i)
  (func (export "add") (param i32 i32) (result i32)
    local.get 0
    local.get 1
    i32.add)
  (data (i32.const 0) "Fifty"))
```

</Details>

Во-вторых парсинг проще, потому что промежуточное представление Wasm ближе тому, что понимает ваша машина.

Весь модуль описывает работу со стеком. Вы можете закидывать туда значения и вынимать их. Например, вытащив два значения из стека вы можете сложить их и закинуть обратно.
Кучи в Wasm нет, зато есть линейная память (все ячейки памяти пронумерованы по порядку). Вы можете использовать эту память чтобы что-то хранить.
Специальный вид памяти – таблицы вызовов функций. Туда вы можете положить указатель на функцию и потом ее вызвать.

<Image {...archtecture} />

## Когда Wasm это медленно

От модуля который никак не взаимодействует с окружающей средой толку мало. У Wasm модуля есть возможность вызывать функции из окружения, и наоборт функции из Wasm модуля можно вызывать непосредственно из окружения.
Но вот вопрос: если такие функции принимают какие-то аргументы или возвращают какие-то значения то где они хранятся? Если мы хотим запихнуть эти аргументы на Wasm стек как нам это сделать?
[Система типов WebAssembly](https://webassembly.github.io/spec/core/syntax/types.html) должна как-то мапиться на типы окружения.
Кроме того система типов языка из которого компилируется WebAssembly модуль должна как-то мапиться на систему типов WebAssembly.
И тут мы встреваем. Ибо WebAssembly умеет манипулировать только чиселками, да и то не всеми. Поэтому чтобы наш WebAssembly модуль мог как-то поработать с аргументами окружения нужно сконвертировать эти аргументы в формат понятный WebAssembly.
И это далеко не всегда быстро.

## GC хорошо или плохо?

GC (Garbage Collector) – сборщик мусора. Если вы когда-нибудь дебажили ваши JavaScript программы, вы могли обратить внимание, что если вы скушаете слишком много памяти, к вам придет GC и будет сурово освобождать место.
На панельке Performance при этом появляются события: Minor GC или Major GC.
Давайте разберемся как это работает:
Если вы будете искать ваши данные вы найдете их в одном из двух мест:
На стеке или на куче. В процессе работы ваша программа работает только со стеком. При этом размер данных на стеке должен быть известен.
Именно поэтому мы не можем положить на стек динамическую структуру данных.
Смотрите:

```JS
const a = [1, 2, 3] // 3 (число элементов в массиве) * 8 (размер числа в байтах) = 24 байта
```

Можно положить `a` на стек? Она весит 24 байта (это, кстати не правда :)
Не можем потому что:

```JS
a.push('Прощайте 8 байт')
```

Поэтому мы закидываем `a` на кучу, а на стек кладем указатель фиксированного размера.
Если место на куче закончится, то GC придет и освободит место. О том как это раньше происходило в V8 можно почитать в [их замечательном блоге](https://v8.dev/blog/trash-talk).
Нам нужно лишь понимать что в процессе сборки мусора, нужно переносить данные в памяти. И при этом вам нужно "остановить" выполнение программы.
Это значит что пока GC работает ваша чудесная JS-анимация замрет и кнопочки перестанут нажиматься. Это называется 'stop-the-world' сборка мусора.
Никто не любит когда кнопочки не нажимаются, поэтому в V8 старается оптимизировать процесс сборки мусора и не останавливать выполнение основного потока слишком надолго: собирать мусор в несколько потоков, делать это небольшим кусочками и пробовать собирать мусор в параллельном потоке.
Но даже такая крутая сборка мусора занимает время.

В WebAssembly нет никакой системы сборки мусора, однако [велики шансы что она скоро появится](https://github.com/WebAssembly/gc/blob/main/proposals/gc/Overview.md)
TODO (объяснить почему)

## Если Wasm это IR, то почему именно браузер?

Wasm это технология созданная для того чтобы интегрироваться в какую-то внешнюю среду, не нанося вреда своему окружению.
Такой средой может быть наша любимая песочница – браузер. Он установлен на всех компьютерах, его умеет запускать даже ваш домашний котик.
Однако в спеке WebAssembly никак не оговорено что ваши модули обязательно должны выполняться в браузере.
Согласно спеке, WebAssembly выполняется в изолированной среде. Никто (без вашего на то разрешения) не может читать стек и память выделенную Wasm модулю.
Именно поэтому нужно придумывать спецификации не только на Wasm но и на окружение. А именно на то какие возможности будет предоставлять окружение вашей сборке.
Если мы говорим про небраузерное окружение, то нам нужно изучать [WASI](https://github.com/WebAssembly/WASI). WASI огромный мир со своими законами. В этой статье я не буду на нем подробно рассказывать.

## И если все-таки браузер...

Достаточно теории, давайте поэкспериментируем.
В одной из свои статей я рассказывала о том [как заблюрить белочку](https://hellsquirrel.dev/blog/how-to-blur-a-squirrel).

Мы делали это при помощи кусочка JavaScript, все было медленно и грусно. TODO: (добавить тайминги на блюр. Они будут очень большими)

Теперь сделаем то же самое, но при помощи WebAssembly и посмотрим, насколько быстрее у нас получилось

## Пишем исходник

В примере мы будем использовать Rust. Программы на Rust очень хорошо компилируются в Wasm из-за особенностей языка.
Модель памяти в Rust отлично мапится на модель памяти в Wasm.

Начнем с того, что перепишем наш блюрящий код на Rust. Вот так он будет выглядеть:

```rust
# TODO: add rust example
```

Теперь соберем сделаем из нашей программки Wasm-модуль.

```bash
# TODO add wasm-pack build example
```

## Подключаем Wasm в браузер

Есть несколько полезных инструментов, которые помогут нам закинуть наш Wasm модуль в бразузер.
Но давайте сделаем все сами:

```js
console.log(blur)
const blurModule = await WebAssembly.instantiateStreaming(fetch('/blur.wasm'), {
  imports: {},
})

const { memory, __heap_base, blur } = obj.instance.blurModule

console.log(blur)
```

Функция `instantiateStreaming` позволяет нам загружать и одновременно выполнять наш модуль
Как только все загрузится и выполнится у нас появляется функция `blur` которой мы и будем блюрить белочку.

## Отправляем белочек в модули

Осталось только понять как именно нам запихнуть нашу белочку в модуль.
Для этого у нас есть две замечательные браузерные апишки

Первая – `canvas`. Тут все просто: берем картинку, грузим, рисуем ее на `canvas`, превращаем `canvas` в `Uint8ClampedArray` и закидываем получившееся в наш модуль.
Но так как мы любим экспериментировать с новыми браузерными апишками, мы лучше используем другой способ.
Загрузим файлик, используя [File System Access API](https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API)

```js
const [openFileHandle] = await window.showOpenFilePicker()
const file = await openFileHandle.getFile()
const contents = await file.arrayBuffer()
```

Теперь запишем нашу белочку в память модуля:

```js
// TODO: add js example
```

Как-то все неудобно, да? Более того, такой процесс еще и достаточно медленный. Насколько проще было бы закинуть файл прямо в Wasm-модуль и пусть он там разбирается что и как.
Кстати, вы можете это сделать используя (`wasm-pack`) (TODO: убедиться что правда можете), но под капотом Wasm-pack сделает все то же самое.
Дело в том, что Wasm умеет работать только с примитивными типами данных. Перемещение данных или функций в и из модуля потратит нам время и ресурсы.
Постепенно этот процесс становится намного проще благодаря [Reference-types](https://github.com/WebAssembly/reference-types/blob/master/proposals/reference-types/Overview.md)

TODO: рассказать про Reference types

<Details title="BigInt64">
  Когда-то даже подружить большие целые числа с Wasm было проблемой. Но потом
  нужный proposal заимплементили в V8, подробности можно почитать [вот
  тут](https://v8.dev/features/wasm-bigint)
</Details>

## Возвращаем белочек из модулей

TODO: добавить пример
Теперь мы готовы блюрить белочку!

```js
// TODO: add blur example with canvas drawing
```

## Замеряем результат

TODO: сравнить результаты блюра с и без Wasm. Объяснить что сравнение не честное, так как завязано на множество разных апишек

## Беличий ускоритель

Теперь потренируемся в скоростном блюре:
Для этого соберем наш модуль немножко по-другому.
TODO: собрать модуль с включенными `simd` и `threads` убедиться что получится быстрее. Рассказать почему.

## Подздравляю! Теперь вы умеете блюрить белочек двумя способами :)

... И разумеется задаетесь вопросом какова же практическая польза этого эксперимента.
Во-первых мы теперь знаем что Wasm это классная изолированная песочница. Поэтому некоторые blockchain проекты используют
WebAssembly как движки для своих смарт-контрактов (TODO: подробности).
Кроме этого Wasm очень дружит с machine learing. У известного фреймворка tensorflow один из бэкендов написан полностью на Wasm (рассказать подробнее что это значит)
Если вы хотите написать плагин для вашей системы, Wasm тоже идеально подойдет
И ходят слухи что [Wasm скоро замених Docker](https://thenewstack.io/when-webassembly-replaces-docker/)! (на самом деле все немного сложнее, но некоторая докероподобная область применения у Wasm есть)
