---
title: 'WebAssembly на клиенте'
date: '2022-11-14T17:03:18.461Z'
tags: ['Wasm']
slug: 'wasm-on-the-client'
published: false
description: Статья о wasm в браузере и не только
---

import { Image } from '../components/Image'
import { Details } from '../components/Details'

import sourceAndTarget from './assets/wasm/sourceAndTarget.png'
import archtecture from './assets/wasm/architecture.png'
import frontendBackend from './assets/wasm/frontendBackend.png'
import { BlurredSquirrel } from '../components/wasm/BlurredSquirrel'
import { BlurredSquirrelNative } from '../components/wasm/BlurredSquirrelNative'

## WebAssembly для всех-всех-всех

В этой статье мы поговорим о WabAssembly – моей любимой технологии, которая позволяет принести на клиент почти все, что в голову взбредет.
Пару лет назад мы с моим коллегой [написали](https://evilmartians.com/chronicles/hands-on-webassembly-try-the-basics) большой тьюториал по Wasm.
Технология за это время осталась такой же прекрасной, в ней появилось много новых штук. Так что сейчас будет еще одна статья про Wasm :)

## Как происходит вжух?

Давайте повторим капитанские основы:

Вы пишете программку на вашем любимом языке (может даже на JS!). А потому вжух и она заработала.
Как происходит вжух? Нечто превращает текст написаный человечком (source) в что-то понятное вашему компьютеру (target).
Это нечто называют интерпертатором или компилятором. В современном мире достаточно сложно отличить одно от другого.
Если хотите разобраться что есть что и как работает, почитайте классную [книжку](https://craftinginterpreters.com/)
Чтобы не запутаться, в нашей статье давайте считать что интерпретатор сразу выполняет исходный код, а компилятор — превращает исходный код в другой – более удобный для выполнения и более низкоуровневый.
Например компилятор может превратить ваш JS в машинные инструкции.

<Image {...sourceAndTarget} />

## Вжух на самом дела вжух-вжух-вжух

Что нужно сделать с вашим исходным кодом, чтобы он превратился в машинный?
Сначала его надо распарсить (убрать наши скучные комменты, понять где функция, где переменная и всякое такое)
Потом, желательно хорошенько перетрясти. Например, вот такой код `const a = 5 + 3` хочется превратить в `положите вон в тот регистр число 8`.
И потом полученное превратить в набор инструкций, понятный процессору.

Для каждого шага компиляции нужно свое промежуточное представление исходного кода.
Например V8 – движок для работы с JS и Wasm в браузере Chromium превращает ваш JavaScript в байт-код, который выглядит примерно так:

```
CreateFunctionContext [0], [1]
PushContext r2
CreateClosure [1], [0], #2
Star1
LdaZero
Star0
StaCurrentContextSlot [2]
CallUndefinedReceiver0 r1, [0]
LdaCurrentContextSlot [2]
Return
```

Компиляция это просто превращение вашего кода из одного промежуточного представления (Intermidiate representation или IR) в другое.

Так как для разных компиляторов шаги компиляции похожи, было бы здорово иметь возможность для каждого шага написать свой модуль, договориться о входных и выходных промежуточных представлениях и просто собирать новые компиляторы из таких модулей.
Обычно так и происходит. Компилятор условно разделяется на две части – фронтенд и бекенд. Фронтенд включает себя шаги более близкие к парсингу, а бекенд – к генерации кода.

<Image {...frontendBackend} />

<Details title="Это ментальная модель, на самом деле все сложнее">
  Цепочка промежуточных представлений может быть и не цепочкой вовсе. Например
  V8 постоянно превращает кусочки вашего кода в разные представления,
  поддерживая одновременно несколько IR. И параллельно собирает фидбек, пытаясь
  предсказать что произойдет дальше и на основе этих предсказаний выбрать
  правильные оптимизации.
</Details>

К чему это я? WebAssembly (или Wasm) это просто промежуточное представление. Достаточно компактное чтобы его было легко распарсить, достаточно низкоуровневое чтобы его можно было оптимизировать.

<Details title="Чуть подробнее">
  Согласно
  [спецификации](https://webassembly.github.io/spec/core/intro/introduction.html#scope),
  Wasm это набор инструкций для абстрактной машины (Virtual ISA). Эта машина
  работает на стеке и делает все, что обычно можно делать со стеком: закидывает
  данные на стек, проделывает с ними всякие арифметические операции и достает
  данные со стека.
</Details>

## Xорошо и быстро

Почему Wasm легко парсить?
Во-первых потому что это бинарный формат. По крайней мере в таком виде Wasm-модуль приезжает в браузер.
У WebAssembly есть и текстовое представление. Вы легко сможете сконвертировать бинарник в текст и обратно.

<Details title="Вот так выглядит текстовый формат WebAssembly">

```
(module
  (func $i (import "imports" "logger") (param i32))
  (memory (import "imports" "importedMemory") 1)
  (func (export "exportedFunc")
    i32.const 42
    call $i)
  (func (export "add") (param i32 i32) (result i32)
    local.get 0
    local.get 1
    i32.add)
  (data (i32.const 0) "Fifty"))
```

</Details>

Во-вторых парсинг проще, потому что промежуточное представление Wasm ближе тому, что понимает ваша машина.

Весь модуль описывает работу со стеком. Вы можете закидывать туда значения и вынимать их. Например, вытащив два значения из стека вы можете сложить их и закинуть обратно.
Кучи в Wasm нет, зато есть линейная память (все ячейки памяти пронумерованы по порядку). Вы можете использовать эту память чтобы что-то хранить.
Эта память ограничена по размеру, но если нужно, размер можно увеличивать.
Специальный вид памяти – таблицы вызовов функций. Туда вы можете положить указатель на функцию и потом ее вызвать.

<Image {...archtecture} />

## <del>Плохо и медленно</del> Может быть медленно

От модуля который никак не взаимодействует с окружающей средой толку мало. У Wasm модуля есть возможность вызывать функции из окружения, и наоборт функции из Wasm модуля можно вызывать непосредственно из окружения.
Но вот вопрос: если такие функции принимают какие-то аргументы или возвращают какие-то значения то где они хранятся? Если мы хотим запихнуть эти аргументы на Wasm стек как нам это сделать?
[Система типов WebAssembly](https://webassembly.github.io/spec/core/syntax/types.html) должна как-то мапиться на типы окружения.
Кроме того система типов языка из которого компилируется WebAssembly модуль должна как-то мапиться на систему типов WebAssembly.
И тут мы встреваем. Ибо WebAssembly умеет манипулировать только чиселками, да и то не всеми. Поэтому чтобы наш WebAssembly модуль мог как-то поработать с аргументами окружения нужно сконвертировать эти аргументы в формат понятный WebAssembly.
И это далеко не всегда быстро.

<Details title="Как мапятся чиселки?">
  WebAssembly может поддерживать вот такие форматы:
  ```
  i32: 32-bit integer, i64: 64-bit integer, f32: 32-bit float, f64: 64-bit float
  ```

Что из этого можно смапить на JavaScript-овый Number?
Давайте выполним вот такой код в консольке:

```js
console.log(Number.MAX_SAFE_INTEGER) // 9007199254740991
```

Это число несколько меньше чем тру int64. Если хотите посчитайте на калькуляторе: (2 ^ 64 - 1)
Получается даже некоторые форматы чисел Wasm не совместимы с браузерным окружением?
Да, некоторое время приходилось читерить и использовать вместо i64 пару (i32, i32),
Но потом Wasm сделали совместимым с JavaScript [BigInt](https://v8.dev/features/bigint) и больше читерить не нужно.

</Details>

## GC хорошо или плохо?

GC (Garbage Collector) – сборщик мусора. Если вы когда-нибудь дебажили JavaScript программы, вы могли обратить внимание, что если скушать слишком много памяти, к вам придет GC и будет сурово освобождать место.
На панельке Performance при этом появляются события: `Minor GC` или `Major GC`.
Давайте разберемся как это работает:
Если вы будете искать ваши данные вы найдете их в одном из двух мест:
На стеке или на куче. В процессе работы ваша программа работает только со стеком. При этом размер данных на стеке должен быть известен.
Именно поэтому мы не можем положить на стек динамическую структуру данных.
Смотрите:

```js
const a = [1, 2, 3] // 3 (число элементов в массиве) * 8 (размер числа в байтах) = 24 байта
```

Можно положить переменную `a` на стек? Она весит 24 байта (это, кстати не правда :)
Не можем потому что:

```js
a.push('Прощайте 24 байта')
```

Поэтому мы закидываем `a` на кучу, а на стек кладем указатель фиксированного размера.
Если место на куче закончится, то GC придет и освободит место. О том как это раньше происходило в V8 можно почитать в [их замечательном блоге](https://v8.dev/blog/trash-talk).
Нам нужно лишь понимать что в процессе сборки мусора, нужно переносить данные в памяти. И при этом вам нужно "остановить" выполнение программы.
Это значит что пока GC работает ваша чудесная JS-анимация замрет и кнопочки перестанут нажиматься. Это называется 'stop-the-world' сборка мусора.
Никто не любит когда кнопочки не нажимаются, поэтому в V8 старается оптимизировать процесс сборки мусора и не останавливать выполнение основного потока слишком надолго: собирать мусор в несколько потоков, делать это небольшим кусочками и пробовать собирать мусор в параллельном потоке.
Но даже такая крутая сборка мусора занимает время.

В WebAssembly нет никакой системы сборки мусора, однако [велики шансы что она скоро появится](https://github.com/WebAssembly/gc/blob/main/proposals/gc/Overview.md)
Сейчас языки со сборкой мусора (например JS) можно спокойно компилировать в Wasm, но нужно понимать, что сборщик мусора придется либо чем-то заменить, либо скомпилировать и добавить в сборку.

## Изоляция из коробки

Низкоуровневый код с бинарным форматом... Куда же его можно приспособить?
Разумеется использовать в браузере. Ведь это наша любимая песочница. Он установлен на всех компьютерах, его умеет запускать даже ваш домашний котик.
Однако в спеке WebAssembly никак не оговорено что ваши модули обязательно должны выполняться в браузере.
Подойдет любой хост, который может скопмилировать и выполнить Wasm. Все что может код внутри модуля – читать выделенную ему область памяти.
Ваш код сидит в коробке и никуда оттуда не убежит (если вы не выдадите ему соответствующий транспорт :)
Разумеется это не значит что используя Wasm модули вы обеспечите безопасность своей системе. Изоляция != безопасность :)

## Что положить в коробку?

Низкоуровневый код с бинарным форматом, высоким уровнем изоляции из коробки и слабой зависимостью от окружения...
Вот бы его еще научить читать файлики и ходить в сеть? Но тут нам понадобится спецификация на все необходимые для этого апишки.
Спроектировать API которое будет предоставлять нужные возможности для Wasm не нарушая изоляцию – очень непростая задача, но ее уже решают :)
Если мы говорим про небраузерное окружение, то посмотрите на [WASI](https://github.com/WebAssembly/WASI). Это набор стандартизованных апишек, которые дают Wasm множество новых возможностей.

## И если все-таки браузер...

Я уже рассказала, что в спеке Wasm ничего не сказано о том, как браузер загружает и выполняем Wasm модули. Все эти апишки описаны в [отдельном документе](https://webassembly.github.io/spec/js-api/index.html).
Для тех кто не пошел читать спеку и для тех кто уже прочитал и вернулся, предлагаю поэкспериментировать.

## Ультаблюр?

Говорят WebAssembly работает быстрее чем JavaScript. Давайте проверим?) В одной из свои статей я рассказывала о том [как заблюрить белочку](https://hellsquirrel.dev/blog/how-to-blur-a-squirrel).
Мы делали это при помощи кусочка JavaScript, все было медленно и грусно.
Теперь сделаем то же самое, но при помощи WebAssembly и посмотрим, насколько быстрее у нас получилось

## Пишем исходник

Сначала напишем блюр на `JavaScript`:

```js
const convStep = (arr1: number[], kernel: number[][]): number =>
  kernel.flat().reduce((acc, v, i) => acc + v * arr1[i], 0)

export const convolve = (
  array: Uint8ClampedArray,
  kernel: number[][],
  w: number,
  h: number,
  chInImage = 4
): Uint8ClampedArray => {
  const result = new Uint8ClampedArray(w * h * chInImage).fill(255)
  const kh = kernel.length
  const kw = kernel[0].length

  for (let i = 0; i < w - kw; i += 1) {
    for (let j = 0; j < h - kh; j += 1) {
      for (let c = 0; c < chInImage; c++) {
        const arrToConsolve: number[] = []
        for (let k = 0; k < kw; k++) {
          for (let l = 0; l < kh; l++) {
            arrToConsolve.push(
              array[
                chInImage * w * j +
                  chInImage * i +
                  c +
                  chInImage * k +
                  chInImage * l * kw
              ]
            )
          }
        }

        const convStepResult = convStep(arrToConsolve, kernel)
        result[chInImage * w * j + chInImage * i + c] = convStepResult
      }
    }
  }

  return result
}

const blurWithJs = (
  pixelData: Uint8ClampedArray,
  width: number,
  height: number
) => convolve(pixelData, blurKernel, width, height, 4)
```

Это достаточно длинный пример, и глубоко вникать в то что там происходит не нужно.
Мы просто пишем ну ооочень неоптимальный цикл, который проходится по каждому пикселю нашей картинки и делает с ним операцию `convolve`
Эта операция "сворачивает" блюрящее ядро с небольшой областью нашей картинки. Подробнее я рассказывала об этом [вот тут](https://hellsquirrel.dev/blog/how-to-blur-a-squirrel)

Теперь то же самое на `Rust`:

```rust

fn conv_step(arr1: &[u8], kernel: &Vec<Vec<f32>>) -> u8 {
    let mut acc = 0.0;
    for (i, v) in kernel.iter().flatten().enumerate() {
        acc += *v * arr1[i] as f32;
    }
    acc as u8
}

pub fn convolve(
    array: &[u8],
    kernel: &Vec<Vec<f32>>,
    w: u32,
    h: u32,
    ch_in_image: u32,
) -> Vec<u8> {
    let mut result = vec![255; (w * h * ch_in_image) as usize];
    let kh = kernel.len() as u32;
    let kw = kernel[0].len() as u32;

    for i in 0..w - kw {
        for j in 0..h - kh {
            for c in 0..ch_in_image {
                let mut arr_to_convolve: Vec<u8> = Vec::with_capacity((kh * kw) as usize);
                for k in 0..kw {
                    for l in 0..kh {
                        arr_to_convolve.push(
                            array[((ch_in_image * w * j
                                + ch_in_image * i
                                + c
                                + ch_in_image * k
                                + ch_in_image * l * kw)
                                as usize)],
                        );
                    }
                }

                let conv_step_result = conv_step(&arr_to_convolve, kernel);
                result[(ch_in_image * w * j + ch_in_image * i + c) as usize] = conv_step_result;
            }
        }
    }

    result
}

pub fn blur_image(array: &[u8], image_width: u32, image_height: u32) -> Vec<u8> {
    let blur_kernel: Vec<Vec<f32>> = vec![
        vec![1.0 / 16.0, 1.0 / 8.0, 1.0 / 16.0],
        vec![1.0 / 8.0, 1.0 / 4.0, 1.0 / 8.0],
        vec![1.0 / 16.0, 1.0 / 8.0, 1.0 / 16.0],
    ];

    convolve(array, &blur_kernel, image_width, image_height, 4)
}

```

<Details title="Кстати, я читерила :)">
  Код на Rust из JS за меня сгенерировал Copilot. Я его даже править не стала :)
</Details>

Если вы внимательно присмотритесь, то, возможно сможете найти парочку отличий. Но их не так уже много :)
Теперь соберем наш rust код в wasm модуль.
Я делаю это по старинке, используя [wasm-pack](https://rustwasm.github.io/wasm-pack/)

<Details title="Подробности">
  Вам нужно создать проект при помощи комманды `wasm-pack new [имя вашего
  проекта]` Написать нужный код и потом собрать все вот такой коммандой
  ```bash
  wasm-pack build --target=web
  ```

Дальше просто скопипастите содержимое папки `pkg` и усе заработает

</Details>

Вот результат :)

<BlurredSquirrel />

Обратите внимание на циферки. При помощи Wasm наша белочка блюрится примерно в 4 раза быстрее.
Если вы загляните во вкладочку `Network` то обнаружите, что wasm-модуль, отвечающий за блюр, весит всего 16КБ.
Это достаточно много, но надо понимать что внутрь нашего модуля пришлось зашить много всего:
функции для работы с памятью, например.

<Details title="И еще чуток килобайт">
  Еще несколько килобайт занимает JS обвязка, которую нам гененрирует wasm-pack.
  Она нужна чтобы корректно загрузить и выполнить наш модуль
</Details>

## Подключаем Wasm в браузер

`Wasm-pack` создаст для вас всю необходимую обвязку чтобы спокойно вызывать wasm-модули в нужном окружении.
Но давайте потренируемся делать все сами.
`Wasm-pack` сгенерировал для нас файл с расширением `.wasm`.
Давайте его загрузим:

```js
const loadModule = async () => {
  const wasmModule = await WebAssembly.instantiateStreaming(
    fetch('/wasm/squirrel_processor_bg.wasm'),
    {
      imports: {},
    }
  )

  return wasmModule.instance.exports
}

const {
  __wbindgen_add_to_stack_pointer: movePointer,
  blur_image,
  __wbindgen_malloc: malloc,
  memory,
} = await loadModule()
```

Функция `instantiateStreaming` позволяет нам загружать и одновременно выполнять наш модуль
Как только все загрузится и выполнится у нас появляется функция `blur_image` которой мы и будем блюрить белочку, а еще мы получим доступ к памяти нашего модуля `memory`
и пару странных функций с нижними подчеркиваиями.

## Отправляем белочек в модули

Осталось только понять как именно нам запихнуть нашу белочку в функцию `blur_image`.
И тут начинаются сложности:
WebAssembly работает с линейной памятью, типа "белка" не поддерживается и даже в роадмапе его нет :(
В эту память мы можем записывать только числа. Так что попробуем преобразовать нашу белку в нужный формат.

Для этого нам пригодятся две замечательные браузерные апишки:

Первая – `canvas`. Тут все просто: берем картинку, грузим, рисуем ее на `canvas`, превращаем `canvas` в `Uint8ClampedArray` и закидываем получившееся в наш модуль.
Но так как мы любим экспериментировать и пробовать новые технологии, мы добавим еще и загрузку файлов.
Загрузим файлик, используя [File System Access API](https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API)

```js
const translateSquirrel = async () => {
  const [openFileHandle] = await window.showOpenFilePicker({
          types: [
            {
              accept: {
                'image/*': ['.png', '.jpg'],
              },
            },
          ],
        })
  const file = await openFileHandle.getFile()
  const bitmap = await createImageBitmap(file)
  const canvas = new OffscreenCanvas(bitmap.width, bitmap.height)
  const ctx = canvas.getContext('2d')
  ctx!.drawImage(bitmap, 0, 0)
  const imageData = new Uint8Array(
    ctx!.getImageData(0, 0, bitmap.width, bitmap.height).data
  )
  return imageData
}
```

Воу-воу, полегче. Что тут происходит?

- Запрашиваем у пользователя файл (`showOpenFilePicker`). Получаем в ответ специальный объект.
- Из этого объекта получаем сам файл (`getFile`)
- Создаем из файла картинку (`createImageBitmap`)
- Рисуем ее на `OffscreenCanvas`. `OffscreenCanvas` – такой магический `canvas` который можно закидывать на `WebWorker`.
- Получаем массив нужного нам формата

## Возвращаем белочек из модулей

Дальше нам понадобятся страшные функции с подчеркиваниями, которые мы притащили из `wasm` модуля.
Обе эти функции нужны для работы с памятью.
Одна работает с указателем на стек, а вторая выделяет память в куче.
Мы не можем просто закинуть наш массив в функцию, Wasm не умеет в массивы!
Поэтому нам надо: выделить память в куче, скопировать туда наш массив, передать указатель на эту память в функцию.
Если вы думаете что блюрящая функция что-то нам вернет, то вы ошибаетесь :)
Она запишет в память получившийся результат. И наша задача его оттуда вытащить.

Я покажу вам как :) (это примерно то же что делает `wasm-bindgen`)

```js
const retptr = movePointer(-16) // подвинули указатель на стеке на 16 байт
const length = imageData.length

const imagePtr = malloc(length) // выделили память в куче
const buff = new Uint8Array(memory.buffer) // получили доступ к памяти
buff.set(imageData, imagePtr) // записали белку

blur_image(retptr, imagePtr, length, bitmap.width, bitmap.height) // заблюрили

const int32View = new Int32Array(memory.buffer) // получили доступ к памяти (ага, снова)
const readStart = int32View[retptr / 4] // получили указатель на начало результата
const readLength = int32View[retptr / 4 + 1] // получили длину результата

const result = new Uint8Array(memory.buffer)
  .subarray(readStart, readStart + readLength)
  .slice() // вжух!
```

<Details title="А почему мы все время создаем новый массив?">
  Внимательный читатель обратил внимание, что мы несколько раз создаем новый
  массив, чтобы читать память. Дело в том, что когда мы работаем с памятью
  внутри Wasm модуля, свойство этой памяти `buffer` может измениться (например
  потому что он вырос) и обращаться к нему по старой ссылке уже не получится.
</Details>

Осталось только нарисовать белку.
Это мы уже умеем :)

```js
const blurredImage = ctx!.createImageData(bitmap.width, bitmap.height)
blurredImage!.data.set(result)
canvas.getContext('2d')?.putImageData(blurredImage, 0, 0)
```

Вот что у нас получилось:

<BlurredSquirrelNative />

<Details title="Хорошо бы освободить память">
  Вообще, нам нужно обязательно освободить память руками. Для этого wasm-модуль
  экспортирует еще одну страшную функцию с подчеркиванием `__wbindgen_free`.
</Details>

## Память это сложно.

Не беспокойтесь. Вам точно не придется писать этот код руками. Ваши инструменты сделают все за вас.
Я хотела обратить ваше внимание на то как данные проходят через границу с Wasm модулем.
Мы рассмотрели очень простой пример, где получилось легко преобразовать все в числа. Но что произойдет если нам, например, понадобится
закинуть внутрь нашего модуля граф... или объект? Не совсем понятно как это мапить на линейную память.

До недавнего времени для этого существовал `workaround` - просто сохранить вашу сущность в каком-нибудь словаре и [передавать Wasm-модулю ключ из словаря вместо этой сущности](https://github.com/WebAssembly/interface-types/issues/18#issuecomment-430605795).
Но недавно в Chromium завезли [WebAssembly Reference Types](https://github.com/WebAssembly/reference-types/blob/master/proposals/reference-types/Overview.md), и теперь не придется писать лишний код и хранить все в словарях.
Вы сможете передавать прям настоящую ссылку на свою сущность в Wasm модуль.

## Подздравляю! Теперь вы можете блюрить белочек в.десять.раз.быстрее :)

Это очень-очень полезно, но мы так и не поняли почему все быстрее.

<Details title="Искусство написания бенчмарков">
  Разумеется наш искусственный пример ни в коем случае не является
  доказательством того что WebAssembly всегда работает быстрее чем JavaScript.
  Чтобы это проверить нужно писать серьезные бенчмарки, считать всякие
  персентили и убедиться что в процессе выполнения ваш мак не облучили из
  космоса и никто не выдернул из него кабель питания.
</Details>

Как я уже говорила, WebAssembly это достаточно низкоуровневое представление.
Его легко и быстро компилировать. Более того, это можно сделать [за один проход](https://v8.dev/docs/wasm-compilation-pipeline).
Кроме этого некоторые оптимизации уже сделали в процессе компиляции исходника в WebAssembly.
Модель WebAssembly это работа с числами на стеке. Такая модель ведет себя достаточно предсказуемо в отличие от JavaScript.
Чтобы эффективно оптимизировать JavaScript движку нужно делать некоторые предположения о вашем коде, например о том с какими аргументами будет вызываться ваша функция.
Когда движок ошибается в своих предположениях ему приходится выбрасывать весь оптимизированный код и использовать неоптимизированную версию.
При выполнении Wasm ничего выкидывать не нужно.

Вот поэтому все быстро :)

## Беличий ускоритель

Как нам ускорить наш блюр? Конечто же все распараллелить.
Для этого в Wasm уже есть несколько инструментов:

- `simd` (SIMD – Single Instruction Multiple Data). Процессоры уже давно научились хитрому трюку: если нужно несколько раз проделать одну и ту же операцию (например несколько раз сложить числа), то эту операцию можно векторизовать.
  Для этого берем пачку чисел для сложения, записываем их в специальный регистр, фетчим только одну специальную команду и применяем сразу ко всей пачке.
  [Wasm так тоже умеет](https://github.com/WebAssembly/simd/blob/master/proposals/simd/SIMD.md) :)

  <Details title="Правда умеет не все">
    Wasm поддерживает только очень ограниченный список SIMD операций –
    Fixed-Width 128-bit SIMD.
  </Details>

- Многопоточность. [Wasm умеет выполняться в несколько потоков](https://github.com/WebAssembly/threads/blob/master/proposals/threads/Overview.md)

  <Details title="Правда с разделяемой памятью есть проблемки">
    Если говорить о браузере, WebAssembly использует в качестве потоков
    WebWorkers. Пошарить память между воркерами не так-то просто. Для этого есть
    крутой инструмент
    [SharedArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer).
    Вот только он уязвим к особой атаке – Spectre. Поэтому в браузерах его
    сначала включили, потом выключили, а потом снова _вроде как_ включили :)
    [Есть отличная статья, где об этом очень подробно
    рассказано](https://web.dev/webassembly-threads/)
  </Details>

## Как и где можно применить WebAssembly?

Итак у нас есть:

- Бинарный, достаточно низкоуровневый формат, который парсится, компилируется и выполняется быстрее чем этот наш JavaScript.
  В этот формат можно компилировать код на множестве языков

  {' '}

  <Details title="Но пока в топе ...">
    ...Языки без сборщика мусора. Rust и C/C++. AssemblyScript тоже замечательно
    компилируется в Wasm.
  </Details>

- Изоляция из коробки
- Отсутствие зависимости от окружения

Где же можно применить все эти классные штуки?

- Быстрый cold start и изоляция делают Wasm очень привлекательной технологией для serverless.
  [Fastly](https://docs.fastly.com/products/compute-at-edge), [Cloudflare](https://blog.cloudflare.com/webassembly-on-cloudflare-workers/) и [Vercel](https://vercel.com/blog/introducing-support-for-webassembly-at-the-edge) поддерживают выполнения Wasm в своих окружениях.

- Изоляция еще очень полезна для написания всяческих плагинов.

- Блокчейны тоже дружат с Wasm :)

- SIMD и быстрое выполнение нужно для задач машинного обучения и всяческих графических эффектов. У JavaScript версии [Tensorflow](https://www.tensorflow.org/js/) есть [WebAssembly-backend](https://blog.tensorflow.org/2020/03/introducing-webassembly-backend-for-tensorflow-js.html).
  Этот бэкенд очень удобно использовать для небольших моделей.

- Если вы хотите портировать в браузер какое-нибудь приложение вам нужно просто скомпилировать его в Wasm :)

## Убедила?

WebAssembly мощная технология. Может быть вам пока не нужно ничего из того о чем я рассказывала, но если вдруг у вас появится нетривиальная задача, заглянув в свой фронтяшный инструментарий, вы найдете там решения для любой задачи :)
