---
title: 'WebAssembly на клиенте'
date: '2022-11-14T17:03:18.461Z'
tags: ['Wasm']
slug: 'wasm-on-the-client'
published: false
description: Статья о wasm в браузере и не только
---

import { Image } from '../components/Image'
import { Details } from '../components/Details'

import sourceAndTarget from './assets/wasm/sourceAndTarget.png'
import archtecture from './assets/wasm/architecture.png'
import { BlurredSquirrel } from '../components/wasm/BlurredSquirrel'

## WebAssembly для всех-всех-всех

В этой статье мы поговорим о WabAssembly – моей любимой технологии, которая позволяет принести на клиент почти все, что в голову взбредет.
Пару лет назад я [написала](https://evilmartians.com/chronicles/hands-on-webassembly-try-the-basics) небольшой тьюториал по Wasm.
Технология за это время осталась такой же прекрасной, в ней появилось много новых штук. Так что сейчас будет еще одна статья про Wasm :)

## Как происходит вжух?

Давайте повторим капитанские основы:

Вы пишете программку на вашем любимом языке (может даже на JS!). А потому вжух и она заработала.
Как происходит вжух? Нечто превращает текст написаный человечком (source) в что-то понятное вашему компьютеру (target).
Это нечто называют интерпертатором или компилятором. В современном мире достаточно сложно отличить одно от другого.
Если хотите разобраться что есть что и как работает, почитайте классную [книжку](https://craftinginterpreters.com/)
Давайте считать что интерпретатор сразу выполняет исходный код без преобразований, а компилятор — превращает программу на исходном языке в программу на другом, более удобном для выполнения, более низкоуровневом, языке.
Например компилятор может превратить ваш JS в машинные инструкции.

<Image {...sourceAndTarget} />

## Вжух на самом дела вжух-вжух-вжух

Что нужно сделать с вашим исходным кодом, чтобы он превратился в машинный?
Сначала его надо распарсить (убрать наши скучные комменты, понять где функция, где переменная и всякое такое)
Потом, желательно хорошенько перетрясти. Например, вот такой код `const a = 5 + 3` хочется превратить в `положите вон в тот регистр число 8`.
И потом полученное превратить в машинный код.

И так как для разных компиляторов эти этапы похожи, было бы здорово иметь возможность для каждого этапа написать свою систему, договориться о входных и выходных форматах и просто собирать новые компиляторы из таких модулей.
Получается компиляция это просто превращение вашего кода из одного промежуточного представления (Intermidiate representation или IR) в другое.

Для каждого шага компиляции выбирается такое промежуточное представление с которым будет удобно работать на нужном шаге.
Например V8 – движок для работы с JS и Wasm в браузере Chromium превращает ваш код в байт-код, который выглядит примерно так:

```
CreateFunctionContext [0], [1]
PushContext r2
CreateClosure [1], [0], #2
Star1
LdaZero
Star0
StaCurrentContextSlot [2]
CallUndefinedReceiver0 r1, [0]
LdaCurrentContextSlot [2]
Return
```

<Details title="Это ментальная модель, на самом деле все сложнее">
  Цепочка промежуточных представлений может быть и не цепочкой вовсе. Например
  V8 постоянно превращает кусочки вашего кода в разные представления,
  поддерживая одновременно несколько IR. И параллельно собирает фидбек, пытаясь
  предсказать что произойдет дальше и на основе этих предсказаний выбрать
  правильные оптимизации.
</Details>

К чему это я? WebAssembly это просто промежуточное представление. Достаточно компактное чтобы его было легко распарсить, достаточно низкоуровневое чтобы его можно было оптимизировать.

## Когда Wasm хорошо и быстро

Почему Wasm легко парсить?
Во-первых потому что это бинарный формат. По крайней мере в таком виде Wasm-модуль приезжает в браузер.
У WebAssembly есть и текстовое представление. Вы легко сможете сконвертировать бинарник в текст и обратно.

<Details title="Вот так выглядит текстовый формат WebAssembly">

```
(module
  (func $i (import "imports" "logger") (param i32))
  (memory (import "imports" "importedMemory") 1)
  (func (export "exportedFunc")
    i32.const 42
    call $i)
  (func (export "add") (param i32 i32) (result i32)
    local.get 0
    local.get 1
    i32.add)
  (data (i32.const 0) "Fifty"))
```

</Details>

Во-вторых парсинг проще, потому что промежуточное представление Wasm ближе тому, что понимает ваша машина.

Весь модуль описывает работу со стеком. Вы можете закидывать туда значения и вынимать их. Например, вытащив два значения из стека вы можете сложить их и закинуть обратно.
Кучи в Wasm нет, зато есть линейная память (все ячейки памяти пронумерованы по порядку). Вы можете использовать эту память чтобы что-то хранить.
Специальный вид памяти – таблицы вызовов функций. Туда вы можете положить указатель на функцию и потом ее вызвать.

<Image {...archtecture} />

## Когда Wasm это медленно

От модуля который никак не взаимодействует с окружающей средой толку мало. У Wasm модуля есть возможность вызывать функции из окружения, и наоборт функции из Wasm модуля можно вызывать непосредственно из окружения.
Но вот вопрос: если такие функции принимают какие-то аргументы или возвращают какие-то значения то где они хранятся? Если мы хотим запихнуть эти аргументы на Wasm стек как нам это сделать?
[Система типов WebAssembly](https://webassembly.github.io/spec/core/syntax/types.html) должна как-то мапиться на типы окружения.
Кроме того система типов языка из которого компилируется WebAssembly модуль должна как-то мапиться на систему типов WebAssembly.
И тут мы встреваем. Ибо WebAssembly умеет манипулировать только чиселками, да и то не всеми. Поэтому чтобы наш WebAssembly модуль мог как-то поработать с аргументами окружения нужно сконвертировать эти аргументы в формат понятный WebAssembly.
И это далеко не всегда быстро.

<Details title="Как мапятся чиселки?">
  WebAssembly может поддерживать вот такие форматы:
  ```
  i32: 32-bit integer, i64: 64-bit integer, f32: 32-bit float, f64: 64-bit float
  ```

Что из этого можно смапить на JavaScript-овый Number?
Давайте выполним вот такой код в консольке:

```js
console.log(Number.MAX_SAFE_INTEGER) // 9007199254740991
```

Это число несколько меньше чем тру int64. Если хотите посчитайте на калькуляторе: (2 ^ 64 - 1)
Получается даже некоторые форматы чисел Wasm не совместимы с браузерным окружением?
Да, некоторое время приходилось читерить и использовать вместо int64 пару (int32, int32),
Но потом Wasm сделали совместимым с JavaScript [BigInt](https://v8.dev/features/bigint) и больше читерить не нужно.

</Details>

## GC хорошо или плохо?

GC (Garbage Collector) – сборщик мусора. Если вы когда-нибудь дебажили ваши JavaScript программы, вы могли обратить внимание, что если вы скушаете слишком много памяти, к вам придет GC и будет сурово освобождать место.
На панельке Performance при этом появляются события: Minor GC или Major GC.
Давайте разберемся как это работает:
Если вы будете искать ваши данные вы найдете их в одном из двух мест:
На стеке или на куче. В процессе работы ваша программа работает только со стеком. При этом размер данных на стеке должен быть известен.
Именно поэтому мы не можем положить на стек динамическую структуру данных.
Смотрите:

```js
const a = [1, 2, 3] // 3 (число элементов в массиве) * 8 (размер числа в байтах) = 24 байта
```

Можно положить переменную `a` на стек? Она весит 24 байта (это, кстати не правда :)
Не можем потому что:

```js
a.push('Прощайте 24 байта')
```

Поэтому мы закидываем `a` на кучу, а на стек кладем указатель фиксированного размера.
Если место на куче закончится, то GC придет и освободит место. О том как это раньше происходило в V8 можно почитать в [их замечательном блоге](https://v8.dev/blog/trash-talk).
Нам нужно лишь понимать что в процессе сборки мусора, нужно переносить данные в памяти. И при этом вам нужно "остановить" выполнение программы.
Это значит что пока GC работает ваша чудесная JS-анимация замрет и кнопочки перестанут нажиматься. Это называется 'stop-the-world' сборка мусора.
Никто не любит когда кнопочки не нажимаются, поэтому в V8 старается оптимизировать процесс сборки мусора и не останавливать выполнение основного потока слишком надолго: собирать мусор в несколько потоков, делать это небольшим кусочками и пробовать собирать мусор в параллельном потоке.
Но даже такая крутая сборка мусора занимает время.

В WebAssembly нет никакой системы сборки мусора, однако [велики шансы что она скоро появится](https://github.com/WebAssembly/gc/blob/main/proposals/gc/Overview.md)
TODO (объяснить почему)

## Если Wasm это IR, то почему именно браузер?

Wasm это технология созданная для того чтобы интегрироваться в какую-то внешнюю среду, не нанося вреда своему окружению.
Такой средой может быть наша любимая песочница – браузер. Он установлен на всех компьютерах, его умеет запускать даже ваш домашний котик.
Однако в спеке WebAssembly никак не оговорено что ваши модули обязательно должны выполняться в браузере.
Согласно спеке, WebAssembly выполняется в изолированной среде. Никто (без вашего на то разрешения) не может читать стек и память выделенную Wasm модулю.
Именно поэтому нужно придумывать спецификации не только на Wasm но и на окружение. А именно на то какие возможности будет предоставлять окружение вашей сборке.
Если мы говорим про небраузерное окружение, то нам нужно изучать [WASI](https://github.com/WebAssembly/WASI). WASI огромный мир со своими законами. В этой статье я не буду на нем подробно рассказывать.

## И если все-таки браузер...

Окей. Давайте проверим все что я тут понарассказывала.

В одной из свои статей я рассказывала о том [как заблюрить белочку](https://hellsquirrel.dev/blog/how-to-blur-a-squirrel).

Мы делали это при помощи кусочка JavaScript, все было медленно и грусно.

Теперь сделаем то же самое, но при помощи WebAssembly и посмотрим, насколько быстрее у нас получилось

## Пишем исходник

Сначала напишем блюр на `JavaScript`:

```js
const convStep = (arr1: number[], kernel: number[][]): number =>
  kernel.flat().reduce((acc, v, i) => acc + v * arr1[i], 0)

export const convolve = (
  array: Uint8ClampedArray,
  kernel: number[][],
  w: number,
  h: number,
  stride = 1,
  chInImage = 4
): Uint8ClampedArray => {
  const result = new Uint8ClampedArray(w * h * chInImage).fill(255)
  const kh = kernel.length
  const kw = kernel[0].length

  for (let i = 0; i < w - kw; i += stride) {
    for (let j = 0; j < h - kh; j += stride) {
      for (let c = 0; c < chInImage; c++) {
        const arrToConsolve: number[] = []
        for (let k = 0; k < kw; k++) {
          for (let l = 0; l < kh; l++) {
            arrToConsolve.push(
              array[
                chInImage * w * j +
                  chInImage * i +
                  c +
                  chInImage * k +
                  chInImage * l * kw
              ]
            )
          }
        }

        const convStepResult = convStep(arrToConsolve, kernel)
        result[chInImage * w * j + chInImage * i + c] = convStepResult
      }
    }
  }

  return result
}

const blurWithJs = (
  pixelData: Uint8ClampedArray,
  width: number,
  height: number
) => convolve(pixelData, blurKernel, width, height)
```

Это достаточно длинный пример, и глубоко вникать в то что там происходит не нужно.
Мы просто пишем ну ооочень неоптимальный цикл, который проходится по каждому пикселю нашей картинки и делает с ним операцию `convolve`
Эта операция "сворачивает" блюрящее ядро с небольшой областью нашей картинки. Подробнее я рассказывала об этом [вот тут](https://hellsquirrel.dev/blog/how-to-blur-a-squirrel)

Теперь то же самое на `Rust`:

```rust

fn conv_step(arr1: &[u8], kernel: &Vec<Vec<f32>>) -> u8 {
    let mut acc = 0.0;
    for (i, v) in kernel.iter().flatten().enumerate() {
        acc += *v * arr1[i] as f32;
    }
    acc as u8
}

pub fn convolve(
    array: &[u8],
    kernel: &Vec<Vec<f32>>,
    w: u32,
    h: u32,
    stride: u32,
    ch_in_image: u32,
) -> Vec<u8> {
    let mut result = vec![255; (w * h * ch_in_image) as usize];
    let kh = kernel.len() as u32;
    let kw = kernel[0].len() as u32;

    for i in 0..w - kw {
        for j in 0..h - kh {
            for c in 0..ch_in_image {
                let mut arr_to_convolve: Vec<u8> = Vec::with_capacity((kh * kw) as usize);
                for k in 0..kw {
                    for l in 0..kh {
                        arr_to_convolve.push(
                            array[((ch_in_image * w * j
                                + ch_in_image * i
                                + c
                                + ch_in_image * k
                                + ch_in_image * l * kw)
                                as usize)],
                        );
                    }
                }

                let conv_step_result = conv_step(&arr_to_convolve, kernel);
                result[(ch_in_image * w * j + ch_in_image * i + c) as usize] = conv_step_result;
            }
        }
    }

    result
}

pub fn blur_image(array: &[u8], image_width: u32, image_height: u32) -> Vec<u8> {
    let blur_kernel: Vec<Vec<f32>> = vec![
        vec![1.0 / 16.0, 1.0 / 8.0, 1.0 / 16.0],
        vec![1.0 / 8.0, 1.0 / 4.0, 1.0 / 8.0],
        vec![1.0 / 16.0, 1.0 / 8.0, 1.0 / 16.0],
    ];

    convolve(array, &blur_kernel, image_width, image_height, 2, 4)
}

```

<Details title="Кстати, я читерила :)">
  Код на Rust из JS за меня сгенерировал Copilot. Я его даже править не стала :)
</Details>

Если вы внимательно присмотритесь, то, возможно сможете найти парочку отличий. Но их не так уже много :)
Теперь соберем наш rust код в wasm модуль.
Я делаю это по старинке, используя [wasm-pack](https://rustwasm.github.io/wasm-pack/)

<Details title="Подробности">
  Вам нужно создать проект при помощи комманды `wasm-pack new [имя вашего
  проекта]` Написать нужный код и потом собрать все вот такой коммандой
  ```bash
  wasm-pack build --target=web
  ```

Дальше просто скопипастите содержимое папки `pkg` и усе заработает

</Details>

Вот результат :)

<BlurredSquirrel />

Обратите внимание на циферки. При помощи Wasm наша белочка блюрится примерно в 4 раза быстрее.
Если вы загляните во вкладочку `Network` то обнаружите, что wasm-модуль, отвечающий за блюр, весит всего 16КБ.
Это достаточно много, но надо понимать что внутрь нашего модуля пришлось зашить много всего:
функции для работы с памятью, например.

<Details title="И еще чуток килобайт">
  Еще несколько килобайт занимает JS обвязка, которую нам гененрирует wasm-pack.
  Она нужна чтобы корректно загрузить и выполнить наш модуль
</Details>

## Подключаем Wasm в браузер

Wasm-pack сгенерирует для вас всю необходимую обвязку чтобы спокойно вызывать ваши wasm-модули в нужном окружении.
Но давайте потренируемся делать все сами.
Wasm-pack сгенерировал для нас файл с расширением `.wasm` и `js обвязку` для него.
Давайте уберем обвязку и попробуем загрузить наш модуль сами.

```js
const wasmModule = await WebAssembly.instantiateStreaming(
  fetch('/wasm/squirrel_processor_bg.wasm'),
  {
    imports: {},
  }
)

const { blur_image, memory } = wasmModule.instance.exports
```

Функция `instantiateStreaming` позволяет нам загружать и одновременно выполнять наш модуль
Как только все загрузится и выполнится у нас появляется функция `blur_image` которой мы и будем блюрить белочку.

## Отправляем белочек в модули

Осталось только понять как именно нам запихнуть нашу белочку в модуль.
Для этого у нас есть две замечательные браузерные апишки

Первая – `canvas`. Тут все просто: берем картинку, грузим, рисуем ее на `canvas`, превращаем `canvas` в `Uint8ClampedArray` и закидываем получившееся в наш модуль.
Но так как мы любим экспериментировать с новыми браузерными апишками, мы лучше используем другой способ.
Загрузим файлик, используя [File System Access API](https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API)

```js
const [openFileHandle] = await window.showOpenFilePicker()
const file = await openFileHandle.getFile()
const contents = await file.arrayBuffer()
```

Теперь запишем нашу белочку в память модуля:

```js
// TODO: add js example
```

Как-то все неудобно, да? Более того, такой процесс еще и достаточно медленный. Насколько проще было бы закинуть файл прямо в Wasm-модуль и пусть он там разбирается что и как.
Кстати, вы можете это сделать используя (`wasm-pack`) (TODO: убедиться что правда можете), но под капотом Wasm-pack сделает все то же самое.
Дело в том, что Wasm умеет работать только с примитивными типами данных. Перемещение данных или функций в и из модуля потратит нам время и ресурсы.
Постепенно этот процесс становится намного проще благодаря [Reference-types](https://github.com/WebAssembly/reference-types/blob/master/proposals/reference-types/Overview.md)

TODO: рассказать про Reference types

<Details title="BigInt64">
  Когда-то даже подружить большие целые числа с Wasm было проблемой. Но потом
  нужный proposal заимплементили в V8, подробности можно почитать [вот
  тут](https://v8.dev/features/wasm-bigint)
</Details>

## Возвращаем белочек из модулей

TODO: добавить пример
Теперь мы готовы блюрить белочку!

```js
// TODO: add blur example with canvas drawing
```

## Замеряем результат

TODO: сравнить результаты блюра с и без Wasm. Объяснить что сравнение не честное, так как завязано на множество разных апишек

## Беличий ускоритель

Теперь потренируемся в скоростном блюре:
Для этого соберем наш модуль немножко по-другому.
TODO: собрать модуль с включенными `simd` и `threads` убедиться что получится быстрее. Рассказать почему.

## Подздравляю! Теперь вы умеете блюрить белочек двумя способами :)

... И разумеется задаетесь вопросом какова же практическая польза этого эксперимента.
Во-первых мы теперь знаем что Wasm это классная изолированная песочница. Поэтому некоторые blockchain проекты используют
WebAssembly как движки для своих смарт-контрактов (TODO: подробности).
Кроме этого Wasm очень дружит с machine learing. У известного фреймворка tensorflow один из бэкендов написан полностью на Wasm (рассказать подробнее что это значит)
Если вы хотите написать плагин для вашей системы, Wasm тоже идеально подойдет
И ходят слухи что [Wasm скоро замених Docker](https://thenewstack.io/when-webassembly-replaces-docker/)! (на самом деле все немного сложнее, но некоторая докероподобная область применения у Wasm есть)

```

```
