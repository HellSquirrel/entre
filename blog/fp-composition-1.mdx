---
title: 'Функциональные штуки . Композиция'
date: '2022-07-16T05:55:58.570Z'
tags: ['FP']
slug: 'fp-composition'
published: true
description: 'Серия статей о функциональном программировании для тех кто об этом ничего не знает. Лайтовое погружение в теорию категорий.'
---

import { Details } from '../components/Details'
import { Formula } from '../components/Formula'
import Pig from './assets/fp/pig.svg'
import RotatedPig from './assets/fp/rotated.svg'
import Pig360 from './assets/fp/360.svg'
import Category from './assets/fp/category.svg'
import Redux from './assets/fp/redux.svg'

# Функциональное

Про функциональный подход говорят часто и много. Кто-то считает что это бесполезная ерунда,
кто-то считает что есть особая секта поклонников функционального программирования с тайной символикой и паролями вида "монада это моноид в категории эндофункторов".
Начинающим фронтятам сообщают что для того чтобы пройти собес нужно знать про чистые функции, но не всегда объясняют зачем они нужны.
Еще очень любят рассказывать про различие в императивном и декларативном подходе. Я, кстати, [тоже так делаю](https://speakerdeck.com/hellsquirrel/ml-for-holyjs?slide=12) :)

Давайте отбросим все эти несомненно полезные знания и попробуем посмотреть на функциональные штуки с другой стороны.
А именно попробуем немножко разобраться в [очень изящной теории](https://en.wikipedia.org/wiki/Category_theory), которая драйвит весь функциональный подход.

# Люди и код

Код пишут люди :) У людей весма ограничена память, поэтому (большинство) писателей кода не создают огромные модули на тысячу строк.
Чтобы как-то управлять сложностью нам нужно разбивать написанное на кусочки и удерживать их в голове.
Также нам нужен какой-то способ строить из кусочков конструкции посложнее. Тогда мы можем забыть о внутренней структуре кусочка и сосредоточиться на форме нашей конструкции.
Если придерживаться определенных правил композиции кусочков мы можем получать крутые спецэффекты и интересные конструкции.
Посему переходим к _композиции_.

# Категории и Композиция

Пусть у нас есть набор объектов. Пусть эти объекты каким-то образом связаны друг с другом. В теории категорий связи называют морфизмами.

Давайте на примере. Пусть у нас есть свинка.

<Pig className="img" />

<Details title="Свинка?">
  Есть замечательная
  [книжка](https://www.blurb.com/b/9621951-category-theory-for-programmers-new-edition-hardco)
  где автор (Bartosz Milewski) объясняет теорию категорий на свинках и стрелках.
  Я насколько вдохновилась этой книжкой что решила для иллюстрации тоже
  использовать хрюшечек :)
</Details>

Повернем свинку.

<RotatedPig className="img" />

А теперь проделаем это несколько раз.

<Category className="img" />

У нас есть категория со свинками, морфизмом в которой является угол поворота хрюши.

Думаете что крутящиеся поросята на очень помогут в разработке? Окей, давайте по-другому. Вот у нас есть Redux.
Redux предполагает что у нас есть глобальный стор, состояние которого мы можем менять при помощи функций редьюсеров. Вот так:

```
const increment = (state, action) => {
  if (action.type === 'INCREMENT') {
    return state + 3;
  }
  return state
}

const decrement = (state, action) => {
  if (action.type === 'DECREMENT') {
    return state - 3;
  }
  return state
}
```

Каждое состояние стора это объект нашей категории. Морфизмы это редьюсеры.
Композиция морфизмов – композиция редьюсеров.

<Redux className="img" />

<Details title="Изоморфизм">
  Возможно, позже мы с вами обсудим что такое изоморфизм. И поймем как заменить
  ваши редьюсеры на крутящихся свинок без потери качества :)
</Details>

Чтобы наша композиция хороша работала, нам нужно чтобы выполнялись несколько законов теории категорий:
Во-первых в нашей категории должен существовать тождественный морфизм (identity) который отображает объект сам в себя.

<Details title="Угадайте что это в категории со свинками">
  Поворот на 360°, 2 * 360°, 3 * 360° и т.д.

{' '}

<Pig360 className="img" />

</Details>

Во-вторых композиция морфизмов должна быть ассоциативной.

<Formula content="h\circ (g\circ f)=(h\circ g)\circ f" />

В-третьих наш тождественный морфизм не должен влиять на получившийся результат:

<Formula content="f\circ \mathrm {id} _{A}=\mathrm {id} _{B}\circ f=f" />

## А что если нарушить правила?

Когда вы делаете плохие штуки в редьюсерах вы можете нарушить эти правила и теория категории вас накажет. Например:
Вы решили проверять вас счетчик на переполнение. И сделать вот так.

```js
const increment = (state, action) => {
  if (state > 5) {
    return 0
  }

  if (action.type === 'INCREMENT') {
    return state + 3
  }

  return state
}

const decrement = (state, action) => {
  if (action.type === 'DECREMENT') {
    return state - 3
  }
  return state
}
```

Тогда increment -> increment -> increment -> decrement == -3

А вот increment -> increment -> (increment -> decrement) == 6

Значения вашего счетчика станут зависимыми не только от того какую кнопочку нажали но и от порядка действий. Это не всегда то что вы хотите.
Мутируя стейт в ваших редьюсерах вы нарушаете оба закона композиции. А потом ваши коллеги будут недовольны пытаясь отловить странные баги в продакшене :)

## Высокие абстракции

Итак все начинается с категорий и композиции. Объектами в категории может быть что угодно. Я не перестаю удивляться как одни и те же законы могут работать для столь разных сущностей.
Обычно мы смотрим на морфизмы как на некоторые функции, а на объекты как на аргументы этих функций. Но мы можем рассматривать морфизмы как объекты некоторой категории, более того мы можем
собирать категории в которых объектами будут другие категории.
Разбираясь во всем этом, мы можем научиться смотреть на системы которые мы разрабатываем чуть-чуть иначе. Это позволит нам находить более интересные и удобные абстракции для наших сущностей и их взаимодействия.
