---
title: 'Магия декларативности и cхемы. Часть 3: Что там за магия такая?'
date: '2022-08-07T08:55:58.570Z'
tags: ['GraphQL', 'Compilers']
slug: declarative-schema-parsing-3
published: true
description: 'Разбираем graphql на винтики'
---

import { Details } from '../components/Details'
import { CodeSnippet } from '../components/CodeSnippet'
import schema from '../components/graphql/schema.graphql'
import { gql } from '@apollo/client'
import validQuery from '../components/graphql/validQuery.graphql'
import getIntrospectionCode from '!raw-loader!../components/graphql/getIntrospection'
import { getIntrospection } from '../components/graphql/getIntrospection'
import { Image } from '../components/Image'
import voyager from './assets/voyager.png'
import graphqlError from './assets/graphqlError.png'
import GraphiQLCode from '!raw-loader!../components/graphql/graphiql'
import { DocView } from '../components/graphql/graphiql'

import ValidationCode from '!raw-loader!../components/graphql/validate'
import { validateQueries } from '../components/graphql/validate'

## Что там было в прошлых сериях?

Мы уже [обсудили что декларативность это круто](/blog/declarative-schema-parsing-1)
и поняли что когда у нас есть схема у нас есть предсказуемость и надежность.
Еще мы теперь знаем как [мокать схему](/blog/declarative-schema-parsing-3)

Давайте посмотрим где нам еще может пригодиться схема

Вспомним наш пример: мы делаем wiki для любителей функционального программирования. Где каждая страничка посвящена алгебраическому типу.

У нас уже есть готовый запрос

<CodeSnippet code={validQuery} lang="graphql" />

И схема

<CodeSnippet code={schema} lang="graphql" />

## Полезные представления схемы.

Мы уже знаем что схема это граф. Но погодите! В графе должны быть кружочки и стрелочки. А тут ничего такого нет. Непорядок!
Исправить это досадное упущение может, например [`graphql-voyager`](https://ivangoncharov.github.io/graphql-voyager/)

Перед тем как рассматривать красивости на основе схемы разберемся с особым запросом к graphql движку – интроспекцией.
Интроспекция это такой же запрос как и все остальные. Однако мы запрашиваем не данные, а информацию о схеме.
Большинство инструментов могут работать как с результатом интроспекции так и со схемой из graphql-файлика.
Но некоторые инструменты требуют именно JSON с интроспекцией. Давайте разберемся как его получить.

<CodeSnippet code={getIntrospectionCode} lang="ts" />

Для нашей схему получается вот такая красивая картиночка

<Image {...voyager} />

Если предполагать что схема хорошо мапится на предметную область: такое отображение может быть очень полезным.

## Документация

Как только у нас появилась схема мы можем красиво скомпоновать нашу информацию о типах и нести ее коллегам. Наша документация будет обновняться вместе со схемой.
И нам не понадобится время и силы на ее поддержку.
Инструментов для генерации подобной документации огромное количество.
Например есть супермощный [ApolloStudioExplorer](https://www.apollographql.com/docs/studio/explorer/explorer/).

<Details title="Apollo studio платформа которая предоставляет множество фич для работы с графом">
  Мы еще несколько раз будем упоминать Apollo Studio по ходу повествования.
</Details>

Но мы возьмем что-то более простое `yarn add graphiql`

<CodeSnippet code={GraphiQLCode} lang="ts" />

Мы получили приятную интерактивную документацию на основе нашей схемы. Как только схема обновится, документация обновится вместе с ней

<DocView />

<Details title="Не забывайте обновлять свои пакеты">
  Все версии graphiql ниже 1.4.7 имеют уязвимость для [XSS
  атак](https://github.com/graphql/graphiql/blob/main/docs/security/2021-introspection-schema-xss.md).
  Поэтому не забывайте обновляться
</Details>

## Ранний отлов ошибок

Чем раньше мы поймаем нашу ошибку тем лучше. Именно поэтому мы так старательно настраиваем линтеры и тесты в наших проектах.
Было бы круто отлавливать все невалидные запросы еще до того как мы все закоммитили в репо.

Во-первых давайте убедимся что у нас здесь есть весь необходимый инструментарий

<CodeSnippet code={ValidationCode} lang="ts" />

<CodeSnippet
  code={() => Promise.resolve(JSON.stringify(validateQueries(), null, ' '))}
  lang="json"
/>

Мы просто вызвали функцию validate из пакета `graphql`. С первым запросом у нас все хорошо, для второго ожидаемо получили ошибку.
Как это можно использовать чтобы улучшить свой DX?

- настроить линтеры. Тут все уже придумали за нас. [Вот этот пакет](https://github.com/B2o5T/graphql-eslint) делает все что нужно.
- настроить расширение для вашей IDE. Для VS Code можно использовать [вот это расширение](https://marketplace.visualstudio.com/items?itemName=GraphQL.vscode-graphql).
  Для IDE от JetBrains есть [вот такой](https://jimkyndemeyer.github.io/js-graphql-intellij-plugin/) замечательный плагин
- не забыть гонять эти проверки на CI. Тут нет ничего Graphql или схема специфического. Стандартный запуск линтеров

Настраивая свой тулинг для IDE загляните [вот
сюда](https://www.graphql-config.com/docs) Вам просто нужно настроить конфиг
под себя и вжух :)

<Details title="Настраивайте небесящие хуки">
  Все легковесный линтеры и тесты удобно гонять на pre-commit hook. Но если ваши
  проверки слишком тяжелые и занимают много времени, то лучше унести их куда-то
  еще. Хорошими кандидатами тут будут pre-push или проверки на CI
</Details>

Для нашего микропримера конфиг будет выглядеть примерно так:

```js
// graphql.config.js
const path = require('path')

module.exports = {
  schema: path.join(__dirname, '/schema.graphql'),
}
```

В результате мы получим симпатичную подсветку синтаксиса

<Image {...graphqlError} />

## Поздний отлов ошибок.

Мы защитились линтерами и плагинами для IDE, но разумеется это не значит что на продакшн все будет гладко.
Давайте рассмотрим несколько примеров:

- Мы пишем вот такой код:

```ts
import { gql } from '@apollo/client'

const strangeDynamicQuery = (fieldName: string) => gql`
  query GetType {
      ${fieldName} {
        name
        description
      }
  }
```

В этом случае линтеры не помогут, так как поле запроса передается динамически. Вы сразу потеряете все преимущества использования схемы.
Я рекомендую не проделывать подобные трюки до тех пор пока у вас нет полной уверенности в том что вы делаете и зачем. Перед тек как вы начнете писать динамические запросы загляните в документацию.
Возможно вы найдете другой более просто и надежный способ решить свою задачу.

- Мы задеплоили новую версию схемы, а часть клиентов сидит с открытыми браузерами. И там _старая_ версия

Все что вы можете сделать на клиенте – поймать ошибку от сервера (хорошие новости: это будет объект с четко определенной структурой) и заслать ее, например в Sentry

<Details title="Искусство отлова">
  То, как правильно репортить ошибки сильно выходит за рамки этой статьи. Здесь
  я лишь порекомендую поискать способ не повторяться. Если на бекенде настроен
  мониторинг ошибок и если он же настроен на фронтенде поищите способ сделать
  так чтобы одна и та же ошибка репортилась и на клиенте и на беке, но вы бы
  понимала что это _действительно_ одна и та же ошибка
</Details>

## И это все?

Мы рассмотрели разные способы визуализации нашей схемы. Следующий пост будет посвящен ленивым фронтам, которые предпочитают генерировать код, а не писать его ручками.
