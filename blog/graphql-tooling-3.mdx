---
title: 'Магия декларативности и схемы. Часть 3: Полезные представления схемы'
date: '2022-08-07T08:55:58.570Z'
tags: ['GraphQL']
slug: declarative-schema-parsing-3
published: true
description: 'Разбираем GraphQL на винтики, учимся понимать декларативный Query Language'
---

import { Details } from '../components/Details'
import { CodeSnippet } from '../components/CodeSnippet'
import schema from '../components/graphql/schema.graphql'
import { gql } from '@apollo/client'
import validQuery from '../components/graphql/validQuery.graphql'
import getIntrospectionCode from '!raw-loader!../components/graphql/getIntrospection'
import { getIntrospection } from '../components/graphql/getIntrospection'
import { Image } from '../components/Image'
import voyager from './assets/voyager.png'
import graphqlError from './assets/graphqlError.png'
import GraphiQLCode from '!raw-loader!../components/graphql/graphiql'
import { DocView } from '../components/graphql/graphiql'

import ValidationCode from '!raw-loader!../components/graphql/validate'
import { validateQueries } from '../components/graphql/validate'

## Что там было в прошлых сериях?

Мы уже [обсудили полезности декларативного подхода](/blog/declarative-schema-parsing-1)
и поняли что использование схем делает наши апишки предсказуемыми и надежными.
Мы научились [мокать схему](/blog/declarative-schema-parsing-3).

Теперь разберемся с полезностями для изучения схемы.

<Details title="Напоминалка про пример">
  Вы уже добрались до третьего поста и наверняка помните, что мы пишем wiki
  для любителей функционального программирования. Каждая страничка посвящена алгебраическому типу.

У нас уже есть готовый запрос

<CodeSnippet code={validQuery} lang="graphql" />

И схема

  <CodeSnippet code={schema} lang="graphql" />
</Details>

## Полезные представления схемы.

Мы уже знаем что схема это граф. Но погодите! В графе должны быть кружочки и стрелочки. А тут ничего такого нет. Непорядок!
Исправить это досадное упущение поможет, например [`graphql-voyager`](https://ivangoncharov.github.io/graphql-voyager/)

Такое представление очень полезно для случаев когда ваша схема хорошо мапится на бизнес-домен. Вы можете посмотреть на
красивую картинку и увидеть связи между сущностями о которых даже не подозревали.
А если у вас есть распределенный граф (о нем я кратко расскажу в следующих постах) подобная визуализация
поможет вам лучше понять как устроена ваша система в целом.

Перед тем как рассматривать красивости на основе схемы разберемся с особым запросом к graphql движку – интроспекцией.
Интроспекция это такой же запрос как и все остальные. Однако мы запрашиваем не данные, а информацию о схеме.
Большинство инструментов могут работать как с результатом интроспекции так и со схемой из graphql-файлика.
Но некоторые инструменты требуют именно JSON с интроспекцией. Вот так мы можем скрафтить нужный JSON:.

<CodeSnippet code={getIntrospectionCode} lang="ts" />

Для нашей схему получается вот такая красивая картиночка

<Image {...voyager} />

Если предполагать что схема хорошо мапится на предметную область: такое отображение может быть очень полезным.

## Документация

Как только у нас появилась схема мы можем красиво скомпоновать нашу информацию о типах и нести ее коллегам. Наша документация будет обновляться вместе со схемой.
И мы будет экономить время и силы на удержание документации в актуальном состоянии. Все будет происходить автомагически :)
Инструментов для генерации подобной документации огромное количество.
Например есть супермощный [ApolloStudioExplorer](https://www.apollographql.com/docs/studio/explorer/explorer/).

<Details title="Apollo studio платформа которая предоставляет множество фич для работы с графом">
  Мы еще несколько раз будем упоминать Apollo Studio по ходу повествования.
</Details>

Но мы возьмем что-то более простое `yarn add graphiql`

<CodeSnippet code={GraphiQLCode} lang="ts" />

Мы получили приятную интерактивную документацию на основе нашей схемы. Как только схема обновится, документация обновится вместе с ней

<DocView />

<Details title="Не забывайте обновлять свои пакеты">
  Все версии graphiql ниже 1.4.7 имеют уязвимость для [XSS
  атак](https://github.com/graphql/graphiql/blob/main/docs/security/2021-introspection-schema-xss.md).
  Поэтому не забывайте обновляться
</Details>

## Ранний отлов ошибок

Чем раньше мы находим ошибки тем лучше. Именно поэтому мы так старательно настраиваем линтеры и тесты в наших проектах.
Было бы круто отлавливать все невалидные запросы еще до того как мы все закоммитили в репозиторий. И уж точно мы хотим найти ошибки до того как наш код уехал на production :)

Давайте убедимся что для этого у нас есть подходящий инструментарий:

<CodeSnippet code={ValidationCode} lang="ts" />

<CodeSnippet
  code={() => Promise.resolve(JSON.stringify(validateQueries(), null, ' '))}
  lang="json"
/>

Мы просто вызвали функцию validate из пакета `graphql`. С первым запросом у нас все хорошо, для второго ожидаемо получили ошибку.
Как это можно использовать чтобы улучшить свой DX?

- настроить линтеры. Тут все уже придумали за нас. [Вот этот пакет](https://github.com/B2o5T/graphql-eslint) делает все что нужно.
- настроить расширение для вашей IDE. Для VS Code можно использовать [вот это расширение](https://marketplace.visualstudio.com/items?itemName=GraphQL.vscode-graphql).
  Для IDE от JetBrains есть [вот такой](https://jimkyndemeyer.github.io/js-graphql-intellij-plugin/) замечательный плагин.
- не забыть гонять эти проверки на CI. Тут нет ничего Graphql или схема специфического. Стандартный запуск линтеров.

У конфига для graphql инструментов есть свой стандарт. Поэтому настраивая свой тулинг для IDE загляните [вот сюда](https://www.graphql-config.com/docs).

<Details title="Настраивайте небесящие хуки">
  Все легковесный линтеры и тесты удобно гонять на `pre-commit hook`. Если ваши
  проверки слишком тяжелые и занимают много времени, то лучше унести их куда-то
  еще. Хорошими кандидатами тут будут pre-push или проверки на CI.
</Details>

Для нашего микропримера конфиг будет выглядеть примерно так:

```js
// graphql.config.js
const path = require('path')

module.exports = {
  schema: path.join(__dirname, '/schema.graphql'),
}
```

В результате мы получим симпатичную подсветку синтаксиса

<Image {...graphqlError} />

## Поздний отлов ошибок.

Мы защитились линтерами и плагинами для IDE, но разумеется это не значит что на production все будет гладко.

Что если напишем вот такой код:

```ts
import { gql } from '@apollo/client'

const strangeDynamicQuery = (fieldName: string) => gql`
  query GetType {
      ${fieldName} {
        name
        description
      }
  }
```

Так как поле запроса `fieldName` передается динамически, линтеры не смогут обнаружить ошибку. Вы сразу потеряете все преимущества использования схемы.
Я рекомендую не проделывать подобные трюки до тех пор пока у вас нет полной уверенности в том что вы делаете и зачем. Перед тем как вы начнете писать динамические запросы загляните в документацию.
Возможно вы найдете другой более просто и надежный способ решить свою задачу.

<Details title="Вообще-то линтеры заметят">
  Для этого надо заменить тип `string` у аргумента `fieldName` на какой-то
  другой. Чуть позже, когда мы обсудим кодогенерацию, у вас должно появиться
  понимание какой тип тут подойдет.
</Details>

- Мы задеплоили новую версию схемы, а часть клиентов сидит с открытыми браузерами. И там _старая_ версия

Все что вы можете сделать на клиенте – поймать ошибку от сервера (хорошие новости: это будет объект с четко определенной структурой) и заслать ее, например в Sentry

<Details title="Искусство отлова">
  То, как правильно репортить ошибки сильно выходит за рамки этой статьи. Здесь
  я лишь порекомендую поискать способ не повторяться. Если мониторинг GraphQL
  ошибок настроен и на клиенте и на сервере, поищите способ сделать так, чтобы
  одна и та же ошибка репортилась и там и там, но вы бы понимала что это
  _действительно_ одна и та же ошибка.
</Details>

## И это все?

Мы рассмотрели разные способы визуализации нашей схемы. [Следующий пост](/blog/declarative-schema-parsing-4) будет посвящен ленивым фронтам, которые предпочитают генерировать код, а не писать его ручками.
